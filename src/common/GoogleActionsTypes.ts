/* generated by script:generateGoogleActionsTypes command */
import * as t from "io-ts";

export type SyncIntentDeviceType = {
  id: string;
  type: keyof typeof DeviceTypeInformation;
  traits: Array<keyof typeof TraitTypeInformation>;
  name: {
    name: string;
    nicknames?: Array<string>;
    defaultNames?: Array<string>;
  },
  willReportState: boolean;
  roomHint?: string;
  attributes: object;
  deviceInfo?: {
    manufacturer: string;
    model: string;
    hwVersion: string;
    swVersion: string;
  };
  // QUERY or EXECUTE
  customData?: { [key: string]: string | boolean | number };
  otherDeviceIds?: Array<{
    deviceId: string;
    agentId?: string;
  }>;
};

export type QueryPayload = {
  devices: Array<{
    id: string;
    customData?: object;
  }>;
};

export type QueryIntentDeviceType = {
  online: boolean;
  statues: 'SUCCESS' | 'OFFLINE' | 'EXCEPTIONS' | 'ERROR',
  errorCode?: string;
  [traitStateKey: string]: any,
};

export type ExecuteIntentPayload = {
  commands: Array<{
    devices: Array<{
      id: string;
      customData?: object;
    }>
    execution: Array<{
      command: string;
      params?: {
        [name: string]: string | number | boolean;
      };
    }>;
  }>;
};

export type ExecuteIntentCommandType = {
  ids: Array<string>;
  status: 'SUCCESS' | 'PENDING' | 'OFFLINE' | 'EXCEPTIONS' | 'ERROR';
  errorCode?: string;
  debugString?: string;
  states?: {
    online: boolean;
    [stateKey: string]: string | number | boolean;
  };
};

export type DeviceType = {
  id: string;
  type: string;
  getTraits: () => Promise<Array<TraitType>>;
  name: {
    name: string;
    nicknames?: Array<string>;
    defaultNames?: Array<string>;
  },
  willReportState: boolean;
  roomHint?: string;
  deviceInfo?: {
    manufacturer: string;
    model: string;
    hwVersion: string;
    swVersion: string;
  };
  // QUERY or EXECUTE
  customData?: { [key: string]: string | boolean | number };
  otherDeviceIds?: Array<{
    deviceId: string;
    agentId?: string;
  }>;
};


type TraitType<A = any, S = any, C extends TraitCommandType<string, any> = any> = {
  type: string;

  // SYNC
  getAttributes: () => Promise<A>;

  getStates: () => Promise<S>;

  getCommands: () => Promise<C[]>;
};

type TraitCommandType<T extends string, P> = {
  type: T;
  parameters: P;
};

export type TypeObject = {
  name: string;
  type: string;
  required: boolean;
  prop: TypeObjectWithKey | string | undefined;
};

export type TypeObjectWithKey = {
  [key: string]: TypeObject;
};

export const DeviceTypeInformation = {
  'action.devices.types.AC_UNIT': {
    name: 'Air conditioning unit',
    type: 'action.devices.types.AC_UNIT',
    description: 'Air conditioning units are similar to thermostats, but do not support heating and may not support setting temperature targets, but rather rely on modes, toggles, and fan speed settings (for example, high and low).',
    recommendedTrains: [
      'FanSpeed',
      'OnOff',
      'TemperatureSetting',
    ],
  },
  'action.devices.types.AIRCOOLER': {
    name: 'Air cooler',
    type: 'action.devices.types.AIRCOOLER',
    description: 'Air coolers are devices that allow temperature cooling and humidity control. These devices are typically more lightweight and portable than air conditioners, and have a water tank attached. Air coolers may not support heating or setting exact temperatures. Interactions with air coolers may include changing the fan speed and humidity setting.',
    recommendedTrains: [
      'FanSpeed',
      'HumiditySetting',
      'Modes',
      'OnOff',
      'TemperatureSetting',
      'Toggles',
    ],
  },
  'action.devices.types.AIRFRESHENER': {
    name: 'Air freshener',
    type: 'action.devices.types.AIRFRESHENER',
    description: 'Air fresheners can be turned on and off and adjust various modes and toggles.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'Toggles',
    ],
  },
  'action.devices.types.AIRPURIFIER': {
    name: 'Air purifier',
    type: 'action.devices.types.AIRPURIFIER',
    description: 'Air purifiers are devices that may be turned on and off, report air filter cleanliness and air filter lifetime, and be adjusted to various mode settings.',
    recommendedTrains: [
      'FanSpeed',
      'Modes',
      'OnOff',
      'SensorState',
      'Toggles',
    ],
  },
  'action.devices.types.AWNING': {
    name: 'Awning',
    type: 'action.devices.types.AWNING',
    description: 'Awnings are retractable and can opened and closed. They can be installed indoors or outdoors.',
    recommendedTrains: [
      'Modes',
      'OpenClose',
    ],
  },
  'action.devices.types.BATHTUB': {
    name: 'Bathtub',
    type: 'action.devices.types.BATHTUB',
    description: 'Bathtubs can be filled and drained, possibly to particular levels if the bathtub supports it.',
    recommendedTrains: [
      'Fill',
      'OnOff',
    ],
  },
  'action.devices.types.BED': {
    name: 'Bed',
    type: 'action.devices.types.BED',
    description: 'Interactions with beds may include adjusting various modes and setting scenes.',
    recommendedTrains: [
      'Modes',
      'Scene',
      'Toggles',
    ],
  },
  'action.devices.types.BLENDER': {
    name: 'Blender',
    type: 'action.devices.types.BLENDER',
    description: 'Interactions with blenders may include starting and stopping, setting a timer, setting cooking modes or food presets, or adjusting other various settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.BLINDS': {
    name: 'Blinds',
    type: 'action.devices.types.BLINDS',
    description: 'Blinds can be opened and closed, and various types of blinds are supported such as venetian (opens in one direction), panel or vertical (may open either left or right), and top-down bottom-up (may open either up or down).',
    recommendedTrains: [
      'Modes',
      'OpenClose',
      'Rotation',
    ],
  },
  'action.devices.types.BOILER': {
    name: 'Boiler',
    type: 'action.devices.types.BOILER',
    description: 'Boilers can be turned on and off, may support adjusting temperature or various modes.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'Toggles',
      'TemperatureControl',
    ],
  },
  'action.devices.types.CAMERA': {
    name: 'Camera',
    type: 'action.devices.types.CAMERA',
    description: 'Cameras are complex and features will vary significantly between vendors. Over time, cameras will acquire many traits and attributes describing specific capabilities, many of which may interact with the video/audio stream in special ways, such as sending a stream to another device, identifying what\'s in the stream, replaying feeds, etc. As such, cameras also interact with other devices - especially screens and other media targets.',
    recommendedTrains: [
      'CameraStream',
    ],
  },
  'action.devices.types.CARBON_MONOXIDE_DETECTOR': {
    name: 'Carbon monoxide detector',
    type: 'action.devices.types.CARBON_MONOXIDE_DETECTOR',
    description: 'Carbon monoxide detectors may report whether carbon monoxide is currently detected, whether the carbon monoxide level is high, and the current carbon monoxide level in parts per million.',
    recommendedTrains: [
      'SensorState',
    ],
  },
  'action.devices.types.CHARGER': {
    name: 'Charger',
    type: 'action.devices.types.CHARGER',
    description: 'Interactions with chargers may include starting and stopping charging, and checking the current charge level, capacity remaining, and capacity until full values.',
    recommendedTrains: [
      'EnergyStorage',
    ],
  },
  'action.devices.types.CLOSET': {
    name: 'Closet',
    type: 'action.devices.types.CLOSET',
    description: 'Closets can be opened and closed, potentially in more than one direction.',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.COFFEE_MAKER': {
    name: 'Coffee maker',
    type: 'action.devices.types.COFFEE_MAKER',
    description: 'Interactions with coffee makers may include turning them on and off, adjusting cooking modes and food presets, adjusting the target temperature, and adjusting various non-cooking mode settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'TemperatureControl',
      'Toggles',
    ],
  },
  'action.devices.types.COOKTOP': {
    name: 'Cooktop',
    type: 'action.devices.types.COOKTOP',
    description: 'Interactions with cooktops may include turning them on and off, starting and stopping, setting a timer, adjusting cooking modes and food presets, and adjusting various non-cooking mode settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.CURTAIN': {
    name: 'Curtain',
    type: 'action.devices.types.CURTAIN',
    description: 'Curtains can be opened and closed, potentially in more than one direction. For example, curtains with two sections may open either to the left or to the right.',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.DEHUMIDIFIER': {
    name: 'Dehumidifier',
    type: 'action.devices.types.DEHUMIDIFIER',
    description: 'Dehumidifiers are devices that remove moisture from the air. They can be turned on and off, report and adjust target humidity, and may have various adjustables modes, toggles, or fan speed settings.',
    recommendedTrains: [
      'FanSpeed',
      'HumiditySetting',
      'Modes',
      'OnOff',
      'RunCycle',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.DEHYDRATOR': {
    name: 'Dehydrator',
    type: 'action.devices.types.DEHYDRATOR',
    description: 'Interactions with dehydrators may include starting and stopping, setting a timer, adjusting cooking modes or food presets, or adjusting other various settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.DISHWASHER': {
    name: 'Dishwasher',
    type: 'action.devices.types.DISHWASHER',
    description: 'Dishwashers can have start and stop functionality independent from being on or off (some washers have separate power buttons, and some do not). Some can be paused and resumed while washing.Dishwashers also have various modes and each mode has its own related settings. These are specific to the dishwasher and are interpreted in a generalized form.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'RunCycle',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.DOOR': {
    name: 'Door',
    type: 'action.devices.types.DOOR',
    description: 'Door can be opened and closed, potentially in more than one direction .',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.DRAWER': {
    name: 'Drawer',
    type: 'action.devices.types.DRAWER',
    description: 'Drawers can be opened and closed, potentially in more than one direction.',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.DRYER': {
    name: 'Dryer',
    type: 'action.devices.types.DRYER',
    description: 'Dryers have start and stop functionality independent from being on or off. Some can be paused and resumed while drying. Dryers also have various modes and each mode has its own related settings. These are specific to the dryer and are interpreted in a generalized form.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'RunCycle',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.FAN': {
    name: 'Fan',
    type: 'action.devices.types.FAN',
    description: 'Fans can typically be turned on and off and have speed settings. Some fans may also have additional supported modes, such as fan direction/orientation (for example, a wall unit may have settings to adjust whether it blows up or down).',
    recommendedTrains: [
      'FanSpeed',
      'Modes',
      'OnOff',
      'Toggles',
    ],
  },
  'action.devices.types.FAUCET': {
    name: 'Faucet',
    type: 'action.devices.types.FAUCET',
    description: 'Faucets can dispense liquids in various quantities and presets.',
    recommendedTrains: [
      'Dispense',
      'Modes',
      'OnOff',
      'StartStop',
    ],
  },
  'action.devices.types.FIREPLACE': {
    name: 'Fireplace',
    type: 'action.devices.types.FIREPLACE',
    description: 'Fireplaces can be turned on and off, and may have adjustable modes and toggles.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'Toggles',
    ],
  },
  'action.devices.types.FREEZER': {
    name: 'Freezer',
    type: 'action.devices.types.FREEZER',
    description: 'Freezers are temperature-managing devices which may be adjusted to various mode settings, and may allow temperature monitoring.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'TemperatureControl',
      'Toggles',
    ],
  },
  'action.devices.types.FRYER': {
    name: 'Fryer',
    type: 'action.devices.types.FRYER',
    description: 'Interactions with fryers may include starting and stopping, setting a timer, adjusting cooking modes or food presets, or adjusting other various settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.GARAGE': {
    name: 'Garage Door',
    type: 'action.devices.types.GARAGE',
    description: 'Garage doors can open, close, and detect an open state. They can also indicate if an object has obstructed the path of the door while closing or if the door is locked and therefore cannot be controlled.',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.GATE': {
    name: 'Gate',
    type: 'action.devices.types.GATE',
    description: 'Gates can be opened and closed, potentially in more than on direction .',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.GRILL': {
    name: 'Grill',
    type: 'action.devices.types.GRILL',
    description: 'Interactions with grills may include turning them on and off, starting and stopping, setting a timer, adjusting cooking modes and food presets, and adjusting various non-cooking mode settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.HEATER': {
    name: 'Heater',
    type: 'action.devices.types.HEATER',
    description: 'Heaters are similar to thermostats but do not support cooling and may not support setting temperature targets. Heaters may rely on modes, toggles, and fan speed settings.',
    recommendedTrains: [
      'FanSpeed',
      'OnOff',
      'TemperatureSetting',
    ],
  },
  'action.devices.types.HOOD': {
    name: 'Hood',
    type: 'action.devices.types.HOOD',
    description: 'Oven and range hoods can be turned on and off, may have adjustable modes, and may have adjustable fan speeds.',
    recommendedTrains: [
      'FanSpeed',
      'Modes',
      'OnOff',
      'Toggles',
    ],
  },
  'action.devices.types.HUMIDIFIER': {
    name: 'Humidifier',
    type: 'action.devices.types.HUMIDIFIER',
    description: 'Humidifiers are devices that add moisture to the air. They can be turned on and off, report and adjust target humidity, and may have various adjustable modes, toggles, or fan speed settings.',
    recommendedTrains: [
      'FanSpeed',
      'HumiditySetting',
      'Modes',
      'OnOff',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.KETTLE': {
    name: 'Kettle',
    type: 'action.devices.types.KETTLE',
    description: 'Kettles are devices that boil water. Interactions with kettles may include turning them on and off, adjusting the target temperature, and perhaps adjusting various mode settings.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'TemperatureControl',
      'Toggles',
    ],
  },
  'action.devices.types.LIGHT': {
    name: 'Light',
    type: 'action.devices.types.LIGHT',
    description: 'This type indicates that the device gets the light bulb icon and some light synonyms/aliases.',
    recommendedTrains: [
      'Brightness',
      'ColorSetting',
      'OnOff',
    ],
  },
  'action.devices.types.LOCK': {
    name: 'Lock',
    type: 'action.devices.types.LOCK',
    description: 'Locks can lock, unlock, and report a locked state. Unlocking is a security sensitive action which can require two-factor authentication.',
    recommendedTrains: [
      'LockUnlock',
    ],
  },
  'action.devices.types.REMOTECONTROL': {
    name: 'Media remote',
    type: 'action.devices.types.REMOTECONTROL',
    description: 'Media remotes are used to control media devices. Examples of this device type include hubs, universal remotes, and media controllers.',
    recommendedTrains: [
      'AppSelector',
      'InputSelector',
      'MediaState',
      'OnOff',
      'Toggles',
      'TransportControl',
      'Volume',
    ],
  },
  'action.devices.types.MOP': {
    name: 'Mop',
    type: 'action.devices.types.MOP',
    description: 'Interactions with mops may include starting, stopping, pausing cleaning, docking, checking the current cleaning cycle, locating the mop, or adjusting various modes and toggles. Some mops may support cleaning specific zones in the home.',
    recommendedTrains: [
      'Dock',
      'Locator',
      'Modes',
      'OnOff',
      'RunCycle',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.MOWER': {
    name: 'Mower',
    type: 'action.devices.types.MOWER',
    description: 'Interactions with mowers may include starting, stopping and pausing mowing, docking, checking the current cycle, locating the mower, and adjusting various modes and toggles.',
    recommendedTrains: [
      'Dock',
      'Locator',
      'Modes',
      'OnOff',
      'RunCycle',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.MICROWAVE': {
    name: 'Microwave',
    type: 'action.devices.types.MICROWAVE',
    description: 'Interactions with microwaves may include starting and stopping, setting a timer, adjusting cooking modes and food presets, and adjusting non-cooking modes (such as the power level) and toggles (such as a light).',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.MULTICOOKER': {
    name: 'Multicooker',
    type: 'action.devices.types.MULTICOOKER',
    description: 'Interactions with multicookers may include starting and stopping, setting a timer, or adjusting various modes and toggles.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.NETWORK': {
    name: 'Network',
    type: 'action.devices.types.NETWORK',
    description: 'Represents a group of router nodes or a mesh network controlled as one entity rather than as individual devices. The network device may reboot, update its software, and have modes to handle Quality of service (QoS) controls and parental restrictions. The device can perform operations such as enabling the guest network, and reporting network-specific information such as the current internet throughput rates.',
    recommendedTrains: [
      'Modes',
      'Toggles',
      'Reboot',
      'SoftwareUpdate',
      'NetworkControl',
    ],
  },
  'action.devices.types.OUTLET': {
    name: 'Outlet',
    type: 'action.devices.types.OUTLET',
    description: 'This type indicates that the device gets the plug icon and some outlet synonyms/aliases.',
    recommendedTrains: [
      'OnOff',
    ],
  },
  'action.devices.types.OVEN': {
    name: 'Oven',
    type: 'action.devices.types.OVEN',
    description: 'Interaction with ovens involves the ability to bake or broil at certain temperatures. The physical temperature inside the oven differs as the oven is heating, so this may also be monitored. The oven has a cook time that limits the duration of baking.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'TemperatureControl',
      'Toggles',
    ],
  },
  'action.devices.types.PERGOLA': {
    name: 'Pergola',
    type: 'action.devices.types.PERGOLA',
    description: 'Pergolas (an outdoor garden structure) can be opened and closed, potentially in more than one direction. For example, some pergolas with a canvas may open either to the LEFT or RIGHT.',
    recommendedTrains: [
      'OpenClose',
      'Rotation',
    ],
  },
  'action.devices.types.PETFEEDER': {
    name: 'Pet feeder',
    type: 'action.devices.types.PETFEEDER',
    description: 'Interactions with pet feeders may include dispensing pet food or water in various quantities and presets, and adjusting various modes and toggles.',
    recommendedTrains: [
      'Dispense',
      'Modes',
      'OnOff',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.PRESSURECOOKER': {
    name: 'Pressure cooker',
    type: 'action.devices.types.PRESSURECOOKER',
    description: 'Interactions with pressure cookers may include starting and stopping, setting a timer, adjusting cooking modes or food presets, or adjusting other various settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.RADIATOR': {
    name: 'Radiator',
    type: 'action.devices.types.RADIATOR',
    description: 'Interactions with radiators may include turning them on and off, and adjusting various modes and toggles.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'Toggles',
    ],
  },
  'action.devices.types.REFRIGERATOR': {
    name: 'Refrigerator',
    type: 'action.devices.types.REFRIGERATOR',
    description: 'This type indicates that the device gets the appropriate icon and some refrigerator synonyms/aliases. Refrigerators are temperature-managing devices which may have various modes/settings.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'TemperatureControl',
      'Toggles',
    ],
  },
  'action.devices.types.ROUTER': {
    name: 'Router',
    type: 'action.devices.types.ROUTER',
    description: 'Routers can reboot, update their software, have modes to handle Quality of service (QoS) controls and parental restrictions, and perform network specific operations (such as enabling the guest network and reporting network specific information such as the current internet throughput rates).',
    recommendedTrains: [
      'Modes',
      'Toggles',
      'Reboot',
      'SoftwareUpdate',
      'NetworkControl',
    ],
  },
  'action.devices.types.SCENE': {
    name: 'Scene',
    type: 'action.devices.types.SCENE',
    description: 'Scenes defined here are partner scenes, implemented as virtual devices and activated by name.',
    recommendedTrains: [
      'Scene',
    ],
  },
  'action.devices.types.SENSOR': {
    name: 'Sensor',
    type: 'action.devices.types.SENSOR',
    description: 'A single sensor can serve multiple functions, such as monitoring both temperature and humidity. Sensors may report either or both quantitative—for example, carbon monoxide and smoke level measured at parts per million—and qualitative measurements (such as whether air quality is healthy or unhealthy).',
    recommendedTrains: [
      'HumiditySetting',
      'Modes',
      'OnOff',
      'SensorState',
    ],
  },
  'action.devices.types.SECURITYSYSTEM': {
    name: 'Security system',
    type: 'action.devices.types.SECURITYSYSTEM',
    description: 'Security systems can be armed and disarmed. They can be armed at multiple security levels (for example, home and away) and they can report information about certain sensors, such as a sensor that detects motion or an open window. Disarming a security system is a sensitive action which may require two-factor authentication.',
    recommendedTrains: [
      'ArmDisarm',
      'SensorState',
      'StatusReport',
    ],
  },
  'action.devices.types.SETTOP': {
    name: 'Set-top box',
    type: 'action.devices.types.SETTOP',
    description: 'Interactions with Multichannel Video Programming Distributor (MVPD) and set-top-box devices may include controlling media playback.',
    recommendedTrains: [
      'AppSelector',
      'InputSelector',
      'MediaState',
      'OnOff',
      'TransportControl',
      'Volume',
    ],
  },
  'action.devices.types.SHUTTER': {
    name: 'Shutter',
    type: 'action.devices.types.SHUTTER',
    description: 'Shutters can be opened and closed, potentially in more than one direction.',
    recommendedTrains: [
      'Modes',
      'OpenClose',
      'Rotation',
    ],
  },
  'action.devices.types.SHOWER': {
    name: 'Shower',
    type: 'action.devices.types.SHOWER',
    description: 'Showers can be turned on and off, start and stop, and may support adjusting temperature or various modes.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'StartStop',
      'TemperatureControl',
    ],
  },
  'action.devices.types.SMOKE_DETECTOR': {
    name: 'Smoke detector',
    type: 'action.devices.types.SMOKE_DETECTOR',
    description: 'Smoke detectors can report whether smoke is currently detected, whether the smoke level is high, and the current smoke level in parts per million.',
    recommendedTrains: [
      'SensorState',
    ],
  },
  'action.devices.types.SOUSVIDE': {
    name: 'Sous vide',
    type: 'action.devices.types.SOUSVIDE',
    description: 'Interactions with sous vides may include starting and stopping, setting a timer, adjusting cooking modes or food presets, or adjusting other various settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
  'action.devices.types.SPRINKLER': {
    name: 'Sprinkler',
    type: 'action.devices.types.SPRINKLER',
    description: 'Sprinklers can start and stop (or turn on and off). In the future, they may support timers and/or schedules.',
    recommendedTrains: [
      'StartStop',
    ],
  },
  'action.devices.types.STANDMIXER': {
    name: 'Stand mixer',
    type: 'action.devices.types.STANDMIXER',
    description: 'Interactions with stand mixers may include turning mixers on and off, starting and stopping the mixer, adjusting cooking modes or food presets, or adjusting various non-cooking mode settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.SWITCH': {
    name: 'Switch',
    type: 'action.devices.types.SWITCH',
    description: 'This type indicates that the device gets the switch icon and some switch synonyms/aliases.',
    recommendedTrains: [
      'OnOff',
    ],
  },
  'action.devices.types.TV': {
    name: 'Television',
    type: 'action.devices.types.TV',
    description: 'Television devices include smart TV devices, over-the-top (OTT) streaming boxes, and OTT streaming sticks.',
    recommendedTrains: [
      'AppSelector',
      'InputSelector',
      'MediaState',
      'Modes',
      'OnOff',
      'Toggles',
      'TransportControl',
      'Volume',
    ],
  },
  'action.devices.types.THERMOSTAT': {
    name: 'Thermostat',
    type: 'action.devices.types.THERMOSTAT',
    description: 'Thermostats are temperature-managing devices, with set points and modes. This separates them from heaters and AC units which may only have modes and settings (for example, high/low) vs a temperature target.',
    recommendedTrains: [
      'TemperatureSetting',
    ],
  },
  'action.devices.types.VACUUM': {
    name: 'Vacuum',
    type: 'action.devices.types.VACUUM',
    description: 'Vacuums may have functions such as starting, stopping, and pausing cleaning, docking, checking the current cleaning cycle, locating the vacuum, or adjusting various modes such as turbo mode, and toggles such as quiet. Some vacuums may support cleaning specific zones in the home.',
    recommendedTrains: [
      'Dock',
      'Modes',
      'OnOff',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.VALVE': {
    name: 'Valve',
    type: 'action.devices.types.VALVE',
    description: 'Valves can be opened and closed.',
    recommendedTrains: [
      'OpenClose',
    ],
  },
  'action.devices.types.WASHER': {
    name: 'Washer',
    type: 'action.devices.types.WASHER',
    description: 'Washers can have start and stop functionality independent from being on or off (some washers have separate power buttons, and some do not). Some can be paused and resumed while washing. Washers also have various modes and each mode has its own related settings. These are specific to the washer and are interpreted in a generalized form.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'RunCycle',
      'StartStop',
      'Toggles',
    ],
  },
  'action.devices.types.WATERHEATER': {
    name: 'Water heater',
    type: 'action.devices.types.WATERHEATER',
    description: 'Water heaters are devices used to heat water. They may turn on and off, adjust water temperature, or adjust various modes/toggles.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'TemperatureControl',
      'Toggles',
    ],
  },
  'action.devices.types.WATERPURIFIER': {
    name: 'Water purifier',
    type: 'action.devices.types.WATERPURIFIER',
    description: 'Water purifiers are devices that may be turned on and off, report water filter cleanliness and filter lifetime, and be adjusted to various mode settings.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'SensorState',
      'Toggles',
    ],
  },
  'action.devices.types.WATERSOFTENER': {
    name: 'Water softener',
    type: 'action.devices.types.WATERSOFTENER',
    description: 'Water softeners are devices that may be turned on and off, report water filter cleanliness and filter lifetime, and be adjusted to various mode settings.',
    recommendedTrains: [
      'Modes',
      'OnOff',
      'SensorState',
      'Toggles',
    ],
  },
  'action.devices.types.WINDOW': {
    name: 'Window',
    type: 'action.devices.types.WINDOW',
    description: 'Windows can be opened and closed, optionally with sections that open in different directions, and may also be locked and unlocked.',
    recommendedTrains: [
      'LockUnlock',
      'OpenClose',
    ],
  },
  'action.devices.types.YOGURTMAKER': {
    name: 'Yogurt maker',
    type: 'action.devices.types.YOGURTMAKER',
    description: 'Interactions with yogurt makers may include starting and stopping, setting a timer, adjusting cooking modes or food presets, or adjusting other various settings.',
    recommendedTrains: [
      'Cook',
      'Modes',
      'OnOff',
      'StartStop',
      'Timer',
      'Toggles',
    ],
  },
};

export const TraitTypeInformation = {
  'action.devices.traits.AppSelector': {
    name: 'AppSelector',
    type: 'action.devices.traits.AppSelector',
    description: 'This trait belongs to devices that support media applications, typically from third parties.',
    commands: [
      'action.devices.commands.appInstall',
      'action.devices.commands.appSearch',
      'action.devices.commands.appSelect',
    ],
    attributes: t.type({
      availableApplications: t.array(t.type({
          key: t.string,
          names: t.array(t.type({
              'name_synonym': t.array(t.string),
              lang: t.string,
            })),
        })),
    }),
    attributesJson: {
      "availableApplications": {
        "name": "availableApplications",
        "type": "array",
        "required": true,
        "prop": {
          "key": {
            "name": "key",
            "type": "string",
            "required": true
          },
          "names": {
            "name": "names",
            "type": "array",
            "required": true,
            "prop": {
              "name_synonym": {
                "name": "name_synonym",
                "type": "array",
                "required": true,
                "prop": "string"
              },
              "lang": {
                "name": "lang",
                "type": "string",
                "required": true
              }
            }
          }
        }
      }
    },
    states: t.type({
      currentApplication: t.string,
    }),
    statesJson: {
      "currentApplication": {
        "name": "currentApplication",
        "type": "string",
        "required": true
      }
    },
  },
  'action.devices.traits.ArmDisarm': {
    name: 'ArmDisarm',
    type: 'action.devices.traits.ArmDisarm',
    description: 'This trait supports arming and disarming as used in, for example, security systems.',
    commands: [
      'action.devices.commands.ArmDisarm',
    ],
    attributes: t.type({
      availableArmLevels: t.union([t.type({
          levels: t.array(t.type({
              'level_name': t.string,
              'level_values': t.array(t.type({
                  'level_synonym': t.array(t.string),
                  lang: t.string,
                })),
            })),
          ordered: t.boolean,
        }), t.undefined]),
    }),
    attributesJson: {
      "availableArmLevels": {
        "name": "availableArmLevels",
        "type": "object",
        "required": false,
        "prop": {
          "levels": {
            "name": "levels",
            "type": "array",
            "required": true,
            "prop": {
              "level_name": {
                "name": "level_name",
                "type": "string",
                "required": true
              },
              "level_values": {
                "name": "level_values",
                "type": "array",
                "required": true,
                "prop": {
                  "level_synonym": {
                    "name": "level_synonym",
                    "type": "array",
                    "required": true,
                    "prop": "string"
                  },
                  "lang": {
                    "name": "lang",
                    "type": "string",
                    "required": true
                  }
                }
              }
            }
          },
          "ordered": {
            "name": "ordered",
            "type": "boolean",
            "required": true
          }
        }
      }
    },
    states: t.type({
      isArmed: t.boolean,
      currentArmLevel: t.type({
          availableArmLevels: t.string,
        }),
      currentStatusReport: t.union([t.unknown, t.undefined]),
      exitAllowance: t.union([t.number, t.undefined]),
    }),
    statesJson: {
      "isArmed": {
        "name": "isArmed",
        "type": "boolean",
        "required": true
      },
      "currentArmLevel": {
        "name": "currentArmLevel",
        "type": "object",
        "required": true,
        "prop": {
          "availableArmLevels": {
            "name": "availableArmLevels",
            "type": "string",
            "required": true
          }
        }
      },
      "currentStatusReport": {
        "name": "currentStatusReport",
        "type": "object",
        "required": false,
        "prop": "unknown"
      },
      "exitAllowance": {
        "name": "exitAllowance",
        "type": "integer",
        "required": false
      }
    },
  },
  'action.devices.traits.Brightness': {
    name: 'Brightness',
    type: 'action.devices.traits.Brightness',
    description: 'Absolute brightness setting is in a normalized range from 0 to 100 (individual lights may not support every point in the range based on their LED configuration).',
    commands: [
      'action.devices.commands.BrightnessAbsolute',
    ],
    attributes: t.type({
      commandOnlyBrightness: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "commandOnlyBrightness": {
        "name": "commandOnlyBrightness",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      brightness: t.number,
    }),
    statesJson: {
      "brightness": {
        "name": "brightness",
        "type": "integer",
        "required": true
      }
    },
  },
  'action.devices.traits.CameraStream': {
    name: 'CameraStream',
    type: 'action.devices.traits.CameraStream',
    description: 'This trait belongs to devices which have the capability to stream video feeds to third party screens, Chromecast-connected screens, or smartphones. By and large, these are security cameras or baby cameras. But this trait also applies to more complex devices which have a camera on them (for example, video-conferencing devices or a vacuum robot with a camera on it).',
    commands: [
      'action.devices.commands.GetCameraStream',
    ],
    attributes: t.type({
      cameraStreamSupportedProtocols: t.array(t.string),
      cameraStreamNeedAuthToken: t.boolean,
      cameraStreamNeedDrmEncryption: t.boolean,
    }),
    attributesJson: {
      "cameraStreamSupportedProtocols": {
        "name": "cameraStreamSupportedProtocols",
        "type": "array",
        "required": true,
        "prop": "string"
      },
      "cameraStreamNeedAuthToken": {
        "name": "cameraStreamNeedAuthToken",
        "type": "boolean",
        "required": true
      },
      "cameraStreamNeedDrmEncryption": {
        "name": "cameraStreamNeedDrmEncryption",
        "type": "boolean",
        "required": true
      }
    },
    states: t.type({    }),
    statesJson: {},
  },
  'action.devices.traits.ColorSetting': {
    name: 'ColorSetting',
    type: 'action.devices.traits.ColorSetting',
    description: 'This trait applies to devices, such as smart lights, that can change color or color temperature.',
    commands: [
      'action.devices.commands.ColorAbsolute',
    ],
    attributes: t.type({
      colorModel: t.string,
      colorTemperatureRange: t.type({
          temperatureMinK: t.number,
          temperatureMaxK: t.number,
        }),
      commandOnlyColorSetting: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "colorModel": {
        "name": "colorModel",
        "type": "string",
        "required": true
      },
      "colorTemperatureRange": {
        "name": "colorTemperatureRange",
        "type": "object",
        "required": true,
        "prop": {
          "temperatureMinK": {
            "name": "temperatureMinK",
            "type": "integer",
            "required": true
          },
          "temperatureMaxK": {
            "name": "temperatureMaxK",
            "type": "integer",
            "required": true
          }
        }
      },
      "commandOnlyColorSetting": {
        "name": "commandOnlyColorSetting",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      color: t.type({
          temperatureK: t.number,
          spectrumRgb: t.number,
          spectrumHsv: t.type({
              hue: t.number,
              saturation: t.number,
              value: t.number,
            }),
        }),
    }),
    statesJson: {
      "color": {
        "name": "color",
        "type": "object",
        "required": true,
        "prop": {
          "temperatureK": {
            "name": "temperatureK",
            "type": "integer",
            "required": true
          },
          "spectrumRgb": {
            "name": "spectrumRgb",
            "type": "integer",
            "required": true
          },
          "spectrumHsv": {
            "name": "spectrumHsv",
            "type": "object",
            "required": true,
            "prop": {
              "hue": {
                "name": "hue",
                "type": "float",
                "required": true
              },
              "saturation": {
                "name": "saturation",
                "type": "float",
                "required": true
              },
              "value": {
                "name": "value",
                "type": "float",
                "required": true
              }
            }
          }
        }
      }
    },
  },
  'action.devices.traits.ColorSpectrum': {
    name: 'ColorSpectrum',
    type: 'action.devices.traits.ColorSpectrum',
    description: 'This trait has been deprecated. Use ColorSetting   instead.This applies to "full" color bulbs that take RGB color ranges. Lights may have any combination of ColorSpectrum and ColorTemperature; accent lights and LED strips may just have Spectrum, whereas some reading bulbs just have Temperature. Basic bulbs, or dumb lights on smart plugs, have neither.',
    commands: [
      'action.devices.commands.ColorAbsolute',
    ],
    attributes: t.type({
      colorModel: t.type({
          hsv: t.union([t.string, t.undefined]),
        }),
    }),
    attributesJson: {
      "colorModel": {
        "name": "colorModel",
        "type": "object",
        "required": true,
        "prop": {
          "hsv": {
            "name": "hsv",
            "type": "string",
            "required": false
          }
        }
      }
    },
    states: t.type({
      color: t.type({
          name: t.string,
          spectrumRGB: t.number,
        }),
    }),
    statesJson: {
      "color": {
        "name": "color",
        "type": "object",
        "required": true,
        "prop": {
          "name": {
            "name": "name",
            "type": "string",
            "required": true
          },
          "spectrumRGB": {
            "name": "spectrumRGB",
            "type": "integer",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.ColorTemperature': {
    name: 'ColorTemperature',
    type: 'action.devices.traits.ColorTemperature',
    description: 'This trait has been deprecated. Use ColorSetting   instead.This applies to "warmth" bulbs that take a color point in Kelvin. This is generally a separate modality from ColorSpectrum, and there may be white points available via Temperature that cannot be reached by Spectrum. Based on available traits, Google may pick the appropriate mode to use based on request and light type (for example, Make the living room lights white might send Temperature commands to some bulbs and Spectrum commands to LED strips).',
    commands: [
      'action.devices.commands.ColorAbsolute',
    ],
    attributes: t.type({
      temperatureMinK: t.type({
          temperatureMaxK: t.union([t.unknown, t.undefined]),
        }),
      temperatureMaxK: t.type({
          temperatureMinK: t.union([t.unknown, t.undefined]),
        }),
    }),
    attributesJson: {
      "temperatureMinK": {
        "name": "temperatureMinK",
        "type": "object",
        "required": true,
        "prop": {
          "temperatureMaxK": {
            "name": "temperatureMaxK",
            "type": "unknown",
            "required": false
          }
        }
      },
      "temperatureMaxK": {
        "name": "temperatureMaxK",
        "type": "object",
        "required": true,
        "prop": {
          "temperatureMinK": {
            "name": "temperatureMinK",
            "type": "unknown",
            "required": false
          }
        }
      }
    },
    states: t.type({
      color: t.type({
          name: t.string,
          temperature: t.number,
        }),
    }),
    statesJson: {
      "color": {
        "name": "color",
        "type": "object",
        "required": true,
        "prop": {
          "name": {
            "name": "name",
            "type": "string",
            "required": true
          },
          "temperature": {
            "name": "temperature",
            "type": "integer",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.Cook': {
    name: 'Cook',
    type: 'action.devices.traits.Cook',
    description: 'This trait belongs to devices that can cook food according to various food presets and supported cooking modes.',
    commands: [
      'action.devices.commands.Cook',
    ],
    attributes: t.type({
      supportedCookingModes: t.string,
      foodPresets: t.union([t.array(t.type({
          'food_preset_name': t.string,
          'supported_units': t.array(t.string),
          'food_synonyms': t.array(t.type({
              synonym: t.array(t.string),
              lang: t.string,
            })),
        })), t.undefined]),
    }),
    attributesJson: {
      "supportedCookingModes": {
        "name": "supportedCookingModes",
        "type": "string",
        "required": true
      },
      "foodPresets": {
        "name": "foodPresets",
        "type": "array",
        "required": false,
        "prop": {
          "food_preset_name": {
            "name": "food_preset_name",
            "type": "string",
            "required": true
          },
          "supported_units": {
            "name": "supported_units",
            "type": "array",
            "required": true,
            "prop": "string"
          },
          "food_synonyms": {
            "name": "food_synonyms",
            "type": "array",
            "required": true,
            "prop": {
              "synonym": {
                "name": "synonym",
                "type": "array",
                "required": true,
                "prop": "string"
              },
              "lang": {
                "name": "lang",
                "type": "string",
                "required": true
              }
            }
          }
        }
      }
    },
    states: t.type({
      currentCookingMode: t.type({
          NONE: t.string,
        }),
      currentFoodPreset: t.type({
          foodPresets: t.union([t.string, t.undefined]),
        }),
      currentFoodQuantity: t.type({
          currentFoodUnit: t.union([t.number, t.undefined]),
        }),
      currentFoodUnit: t.type({
          currentFoodQuantity: t.union([t.string, t.undefined]),
        }),
    }),
    statesJson: {
      "currentCookingMode": {
        "name": "currentCookingMode",
        "type": "object",
        "required": true,
        "prop": {
          "NONE": {
            "name": "NONE",
            "type": "string",
            "required": true
          }
        }
      },
      "currentFoodPreset": {
        "name": "currentFoodPreset",
        "type": "object",
        "required": true,
        "prop": {
          "foodPresets": {
            "name": "foodPresets",
            "type": "string",
            "required": false
          }
        }
      },
      "currentFoodQuantity": {
        "name": "currentFoodQuantity",
        "type": "object",
        "required": true,
        "prop": {
          "currentFoodUnit": {
            "name": "currentFoodUnit",
            "type": "float",
            "required": false
          }
        }
      },
      "currentFoodUnit": {
        "name": "currentFoodUnit",
        "type": "object",
        "required": true,
        "prop": {
          "currentFoodQuantity": {
            "name": "currentFoodQuantity",
            "type": "string",
            "required": false
          }
        }
      }
    },
  },
  'action.devices.traits.Dispense': {
    name: 'Dispense',
    type: 'action.devices.traits.Dispense',
    description: 'This trait belongs to devices that support dispensing a specified amount of one or more physical items. For example, a dog treat dispenser may dispense a number of treats, a faucet may dispense cups of water, and a pet feeder may dispense both water and pet food.',
    commands: [
      'action.devices.commands.Dispense',
    ],
    attributes: t.type({
      supportedDispenseItems: t.array(t.type({
          'item_name': t.string,
          'item_name_synonyms': t.array(t.type({
              lang: t.string,
              synonyms: t.array(t.string),
            })),
          'supported_units': t.array(t.string),
          'default_portion': t.type({
              amount: t.number,
              unit: t.string,
            }),
        })),
    }),
    attributesJson: {
      "supportedDispenseItems": {
        "name": "supportedDispenseItems",
        "type": "array",
        "required": true,
        "prop": {
          "item_name": {
            "name": "item_name",
            "type": "string",
            "required": true
          },
          "item_name_synonyms": {
            "name": "item_name_synonyms",
            "type": "array",
            "required": true,
            "prop": {
              "lang": {
                "name": "lang",
                "type": "string",
                "required": true
              },
              "synonyms": {
                "name": "synonyms",
                "type": "array",
                "required": true,
                "prop": "string"
              }
            }
          },
          "supported_units": {
            "name": "supported_units",
            "type": "array",
            "required": true,
            "prop": "string"
          },
          "default_portion": {
            "name": "default_portion",
            "type": "object",
            "required": true,
            "prop": {
              "amount": {
                "name": "amount",
                "type": "float",
                "required": true
              },
              "unit": {
                "name": "unit",
                "type": "string",
                "required": true
              }
            }
          }
        }
      }
    },
    states: t.type({
      dispenseItems: t.union([t.array(t.type({
          itemName: t.union([t.string, t.undefined]),
          amountRemaining: t.union([t.type({
              amount: t.number,
              unit: t.string,
            }), t.undefined]),
          amountLastDispensed: t.union([t.type({
              amount: t.number,
              unit: t.string,
            }), t.undefined]),
          isCurrentlyDispensing: t.union([t.boolean, t.undefined]),
        })), t.undefined]),
    }),
    statesJson: {
      "dispenseItems": {
        "name": "dispenseItems",
        "type": "array",
        "required": false,
        "prop": {
          "itemName": {
            "name": "itemName",
            "type": "string",
            "required": false
          },
          "amountRemaining": {
            "name": "amountRemaining",
            "type": "object",
            "required": false,
            "prop": {
              "amount": {
                "name": "amount",
                "type": "float",
                "required": true
              },
              "unit": {
                "name": "unit",
                "type": "string",
                "required": true
              }
            }
          },
          "amountLastDispensed": {
            "name": "amountLastDispensed",
            "type": "object",
            "required": false,
            "prop": {
              "amount": {
                "name": "amount",
                "type": "float",
                "required": true
              },
              "unit": {
                "name": "unit",
                "type": "string",
                "required": true
              }
            }
          },
          "isCurrentlyDispensing": {
            "name": "isCurrentlyDispensing",
            "type": "boolean",
            "required": false
          }
        }
      }
    },
  },
  'action.devices.traits.Dock': {
    name: 'Dock',
    type: 'action.devices.traits.Dock',
    description: 'This trait is designed for self-mobile devices that can be commanded to return for charging.',
    commands: [
      'action.devices.commands.Dock',
    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({
      isDocked: t.unknown,
    }),
    statesJson: {
      "isDocked": {
        "name": "isDocked",
        "type": "unknown",
        "required": true
      }
    },
  },
  'action.devices.traits.EnergyStorage': {
    name: 'EnergyStorage',
    type: 'action.devices.traits.EnergyStorage',
    description: 'This trait belongs to devices that can store energy in a battery and potentially recharge, or devices that can charge another device. The trait supports starting and stopping charging, and checking the current charge level, capacity remaining, and capacity until full values.',
    commands: [
      'action.devices.commands.Charge',
    ],
    attributes: t.type({
      queryOnlyEnergyStorage: t.type({
          isRechargeable: t.union([t.boolean, t.undefined]),
        }),
      energyStorageDistanceUnitForUX: t.string,
      isRechargeable: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "queryOnlyEnergyStorage": {
        "name": "queryOnlyEnergyStorage",
        "type": "object",
        "required": true,
        "prop": {
          "isRechargeable": {
            "name": "isRechargeable",
            "type": "boolean",
            "required": false
          }
        }
      },
      "energyStorageDistanceUnitForUX": {
        "name": "energyStorageDistanceUnitForUX",
        "type": "string",
        "required": true
      },
      "isRechargeable": {
        "name": "isRechargeable",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      descriptiveCapacityRemaining: t.string,
      capacityRemaining: t.array(t.type({        })),
    }),
    statesJson: {
      "descriptiveCapacityRemaining": {
        "name": "descriptiveCapacityRemaining",
        "type": "string",
        "required": true
      },
      "capacityRemaining": {
        "name": "capacityRemaining",
        "type": "array",
        "required": true,
        "prop": {}
      }
    },
  },
  'action.devices.traits.FanSpeed': {
    name: 'FanSpeed',
    type: 'action.devices.traits.FanSpeed',
    description: 'This trait belongs to devices that support setting the speed of a fan (that is, blowing air from the device at various levels, which may be part of an air conditioning or heating unit, or in a car), with settings such as low, medium, and high.',
    commands: [
      'action.devices.commands.SetFanSpeed',
      'action.devices.commands.SetFanSpeedRelativeSpeed',
      'action.devices.commands.Reverse',
    ],
    attributes: t.type({
      availableFanSpeeds: t.type({
          speeds: t.array(t.type({
              'speed_name': t.string,
              'speed_values': t.unknown,
            })),
          ordered: t.boolean,
        }),
      reversible: t.boolean,
      supportsFanSpeedPercent: t.boolean,
      commandOnlyFanSpeed: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "availableFanSpeeds": {
        "name": "availableFanSpeeds",
        "type": "object",
        "required": true,
        "prop": {
          "speeds": {
            "name": "speeds",
            "type": "array",
            "required": true,
            "prop": {
              "speed_name": {
                "name": "speed_name",
                "type": "string",
                "required": true
              },
              "speed_values": {
                "name": "speed_values",
                "type": "unknown",
                "required": true
              }
            }
          },
          "ordered": {
            "name": "ordered",
            "type": "boolean",
            "required": true
          }
        }
      },
      "reversible": {
        "name": "reversible",
        "type": "boolean",
        "required": true
      },
      "supportsFanSpeedPercent": {
        "name": "supportsFanSpeedPercent",
        "type": "boolean",
        "required": true
      },
      "commandOnlyFanSpeed": {
        "name": "commandOnlyFanSpeed",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      currentFanSpeedSetting: t.type({
          'action.devices.traits.FanSpeed': t.string,
        }),
      currentFanSpeedPercent: t.number,
    }),
    statesJson: {
      "currentFanSpeedSetting": {
        "name": "currentFanSpeedSetting",
        "type": "object",
        "required": true,
        "prop": {
          "action.devices.traits.FanSpeed": {
            "name": "action.devices.traits.FanSpeed",
            "type": "string",
            "required": true
          }
        }
      },
      "currentFanSpeedPercent": {
        "name": "currentFanSpeedPercent",
        "type": "float",
        "required": true
      }
    },
  },
  'action.devices.traits.Fill': {
    name: 'Fill',
    type: 'action.devices.traits.Fill',
    description: 'This trait applies to devices that support being filled, such as a bathtub.',
    commands: [
      'action.devices.commands.Fill',
    ],
    attributes: t.type({
      availableFillLevels: t.union([t.type({
          levels: t.array(t.type({
              'level_name': t.string,
              'level_values': t.unknown,
              'level_synonym': t.array(t.string),
            })),
          ordered: t.boolean,
        }), t.undefined]),
    }),
    attributesJson: {
      "availableFillLevels": {
        "name": "availableFillLevels",
        "type": "object",
        "required": false,
        "prop": {
          "levels": {
            "name": "levels",
            "type": "array",
            "required": true,
            "prop": {
              "level_name": {
                "name": "level_name",
                "type": "string",
                "required": true
              },
              "level_values": {
                "name": "level_values",
                "type": "unknown",
                "required": true
              },
              "level_synonym": {
                "name": "level_synonym",
                "type": "array",
                "required": true,
                "prop": "string"
              }
            }
          },
          "ordered": {
            "name": "ordered",
            "type": "boolean",
            "required": true
          }
        }
      }
    },
    states: t.type({
      isFilled: t.type({
          levels: t.boolean,
        }),
      currentFillLevel: t.type({
          availableFillLevels: t.string,
        }),
    }),
    statesJson: {
      "isFilled": {
        "name": "isFilled",
        "type": "object",
        "required": true,
        "prop": {
          "levels": {
            "name": "levels",
            "type": "boolean",
            "required": true
          }
        }
      },
      "currentFillLevel": {
        "name": "currentFillLevel",
        "type": "object",
        "required": true,
        "prop": {
          "availableFillLevels": {
            "name": "availableFillLevels",
            "type": "string",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.HumiditySetting': {
    name: 'HumiditySetting',
    type: 'action.devices.traits.HumiditySetting',
    description: 'This trait belongs to devices that support humidity settings such as humidifiers and dehumidifiers.',
    commands: [
      'action.devices.commands.SetHumidity',
      'action.devices.commands.HumidityRelative',
    ],
    attributes: t.type({
      humiditySetpointRange: t.union([t.type({
          minPercent: t.union([t.number, t.undefined]),
          maxPercent: t.union([t.number, t.undefined]),
        }), t.undefined]),
      commandOnlyHumiditySetting: t.union([t.boolean, t.undefined]),
      queryOnlyHumiditySetting: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "humiditySetpointRange": {
        "name": "humiditySetpointRange",
        "type": "object",
        "required": false,
        "prop": {
          "minPercent": {
            "name": "minPercent",
            "type": "integer",
            "required": false
          },
          "maxPercent": {
            "name": "maxPercent",
            "type": "integer",
            "required": false
          }
        }
      },
      "commandOnlyHumiditySetting": {
        "name": "commandOnlyHumiditySetting",
        "type": "boolean",
        "required": false
      },
      "queryOnlyHumiditySetting": {
        "name": "queryOnlyHumiditySetting",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      humiditySetpointPercent: t.type({
          minHumidityPercent: t.union([t.number, t.undefined]),
        }),
      humidityAmbientPercent: t.union([t.number, t.undefined]),
    }),
    statesJson: {
      "humiditySetpointPercent": {
        "name": "humiditySetpointPercent",
        "type": "object",
        "required": true,
        "prop": {
          "minHumidityPercent": {
            "name": "minHumidityPercent",
            "type": "integer",
            "required": false
          }
        }
      },
      "humidityAmbientPercent": {
        "name": "humidityAmbientPercent",
        "type": "integer",
        "required": false
      }
    },
  },
  'action.devices.traits.InputSelector': {
    name: 'InputSelector',
    type: 'action.devices.traits.InputSelector',
    description: 'Trait for devices that can change media inputs. These inputs can have dynamic names per device, and may represent audio or video feeds, hardwired or networked.',
    commands: [
      'action.devices.commands.SetInput',
    ],
    attributes: t.type({
      availableInputs: t.array(t.type({
          key: t.string,
          names: t.array(t.type({
              lang: t.string,
              'name_synonym': t.array(t.string),
            })),
        })),
      commandOnlyInputSelector: t.boolean,
      orderedInputs: t.boolean,
    }),
    attributesJson: {
      "availableInputs": {
        "name": "availableInputs",
        "type": "array",
        "required": true,
        "prop": {
          "key": {
            "name": "key",
            "type": "string",
            "required": true
          },
          "names": {
            "name": "names",
            "type": "array",
            "required": true,
            "prop": {
              "lang": {
                "name": "lang",
                "type": "string",
                "required": true
              },
              "name_synonym": {
                "name": "name_synonym",
                "type": "array",
                "required": true,
                "prop": "string"
              }
            }
          }
        }
      },
      "commandOnlyInputSelector": {
        "name": "commandOnlyInputSelector",
        "type": "boolean",
        "required": true
      },
      "orderedInputs": {
        "name": "orderedInputs",
        "type": "boolean",
        "required": true
      }
    },
    states: t.type({
      currentInput: t.string,
    }),
    statesJson: {
      "currentInput": {
        "name": "currentInput",
        "type": "string",
        "required": true
      }
    },
  },
  'action.devices.traits.LightEffects': {
    name: 'LightEffects',
    type: 'action.devices.traits.LightEffects',
    description: 'This trait belongs to devices that can support complex lighting commands to change state, such as looping through various colors.',
    commands: [
      'action.devices.commands.ColorLoop',
      'action.devices.commands.Sleep',
      'action.devices.commands.StopEffect',
      'action.devices.commands.Wake',
    ],
    attributes: t.type({
      defaultSleepDuration: t.type({
          'action.devices.commands.Sleep': t.union([t.number, t.undefined]),
        }),
      defaultWakeDuration: t.type({
          'action.devices.commands.Wake': t.union([t.number, t.undefined]),
        }),
      supportedEffects: t.array(t.type({
          colorLoop: t.unknown,
          sleep: t.union([t.unknown, t.undefined]),
          wake: t.union([t.unknown, t.undefined]),
        })),
    }),
    attributesJson: {
      "defaultSleepDuration": {
        "name": "defaultSleepDuration",
        "type": "object",
        "required": true,
        "prop": {
          "action.devices.commands.Sleep": {
            "name": "action.devices.commands.Sleep",
            "type": "integer",
            "required": false
          }
        }
      },
      "defaultWakeDuration": {
        "name": "defaultWakeDuration",
        "type": "object",
        "required": true,
        "prop": {
          "action.devices.commands.Wake": {
            "name": "action.devices.commands.Wake",
            "type": "integer",
            "required": false
          }
        }
      },
      "supportedEffects": {
        "name": "supportedEffects",
        "type": "array",
        "required": true,
        "prop": {
          "colorLoop": {
            "name": "colorLoop",
            "type": "unknown",
            "required": true
          },
          "sleep": {
            "name": "sleep",
            "type": "unknown",
            "required": false
          },
          "wake": {
            "name": "wake",
            "type": "unknown",
            "required": false
          }
        }
      }
    },
    states: t.type({
      activeLightEffect: t.union([t.string, t.undefined]),
    }),
    statesJson: {
      "activeLightEffect": {
        "name": "activeLightEffect",
        "type": "string",
        "required": false
      }
    },
  },
  'action.devices.traits.Locator': {
    name: 'Locator',
    type: 'action.devices.traits.Locator',
    description: 'This trait is used for devices that can be "found". This includes phones, robots (including vacuums and mowers), drones, and tag-specific products that attach to other devices.',
    commands: [
      'action.devices.commands.Locate',
    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({    }),
    statesJson: {},
  },
  'action.devices.traits.LockUnlock': {
    name: 'LockUnlock',
    type: 'action.devices.traits.LockUnlock',
    description: 'This trait belongs to any devices that support locking and unlocking, and/or reporting a locked state.',
    commands: [
      'action.devices.commands.LockUnlock',
    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({
      isLocked: t.boolean,
      isJammed: t.boolean,
    }),
    statesJson: {
      "isLocked": {
        "name": "isLocked",
        "type": "boolean",
        "required": true
      },
      "isJammed": {
        "name": "isJammed",
        "type": "boolean",
        "required": true
      }
    },
  },
  'action.devices.traits.MediaState': {
    name: 'MediaState',
    type: 'action.devices.traits.MediaState',
    description: 'This trait is used for devices which are able to report media states.',
    commands: [

    ],
    attributes: t.type({
      supportActivityState: t.boolean,
      supportPlaybackState: t.boolean,
    }),
    attributesJson: {
      "supportActivityState": {
        "name": "supportActivityState",
        "type": "boolean",
        "required": true
      },
      "supportPlaybackState": {
        "name": "supportPlaybackState",
        "type": "boolean",
        "required": true
      }
    },
    states: t.type({
      activityState: t.string,
      playbackState: t.string,
    }),
    statesJson: {
      "activityState": {
        "name": "activityState",
        "type": "string",
        "required": true
      },
      "playbackState": {
        "name": "playbackState",
        "type": "string",
        "required": true
      }
    },
  },
  'action.devices.traits.Modes': {
    name: 'Modes',
    type: 'action.devices.traits.Modes',
    description: 'This trait belongs to any devices with an arbitrary number of "n-way" modes in which the modes and settings for each mode are arbitrary and unique to each device or device type. Each mode has multiple possible settings, but only one can be selected at a time; a dryer cannot be in "delicate," "normal," and "heavy duty" mode simultaneously. A setting that simply can be turned on or off belongs in the Toggles trait.',
    commands: [
      'action.devices.commands.SetModes',
    ],
    attributes: t.type({
      availableModes: t.type({
          name: t.string,
          'name_values': t.unknown,
          settings: t.unknown,
          ordered: t.array(t.unknown),
        }),
      commandOnlyModes: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "availableModes": {
        "name": "availableModes",
        "type": "object",
        "required": true,
        "prop": {
          "name": {
            "name": "name",
            "type": "string",
            "required": true
          },
          "name_values": {
            "name": "name_values",
            "type": "unknown",
            "required": true
          },
          "settings": {
            "name": "settings",
            "type": "unknown",
            "required": true
          },
          "ordered": {
            "name": "ordered",
            "type": "array",
            "required": true,
            "prop": "unknown"
          }
        }
      },
      "commandOnlyModes": {
        "name": "commandOnlyModes",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      currentModeSettings: t.string,
    }),
    statesJson: {
      "currentModeSettings": {
        "name": "currentModeSettings",
        "type": "object",
        "required": true,
        "prop": "string"
      }
    },
  },
  'action.devices.traits.NetworkControl': {
    name: 'NetworkControl',
    type: 'action.devices.traits.NetworkControl',
    description: 'This trait belongs to devices that support reporting network data and performing network specific operations.',
    commands: [
      'action.devices.commands.EnableDisableGuestNetwork',
      'action.devices.commands.EnableDisableNetworkProfile',
      'action.devices.commands.GetGuestNetworkPassword',
      'action.devices.commands.TestNetworkSpeed',
    ],
    attributes: t.type({
      supportsEnablingGuestNetwork: t.boolean,
      supportsDisablingGuestNetwork: t.boolean,
      networkProfiles: t.array(t.string),
      supportsEnablingNetworkProfile: t.boolean,
      supportsDisablingNetworkProfile: t.boolean,
      supportsNetworkDownloadSpeedTest: t.boolean,
      supportsNetworkUploadSpeedTest: t.boolean,
      supportsGettingGuestNetworkPassword: t.boolean,
    }),
    attributesJson: {
      "supportsEnablingGuestNetwork": {
        "name": "supportsEnablingGuestNetwork",
        "type": "boolean",
        "required": true
      },
      "supportsDisablingGuestNetwork": {
        "name": "supportsDisablingGuestNetwork",
        "type": "boolean",
        "required": true
      },
      "networkProfiles": {
        "name": "networkProfiles",
        "type": "array",
        "required": true,
        "prop": "string"
      },
      "supportsEnablingNetworkProfile": {
        "name": "supportsEnablingNetworkProfile",
        "type": "boolean",
        "required": true
      },
      "supportsDisablingNetworkProfile": {
        "name": "supportsDisablingNetworkProfile",
        "type": "boolean",
        "required": true
      },
      "supportsNetworkDownloadSpeedTest": {
        "name": "supportsNetworkDownloadSpeedTest",
        "type": "boolean",
        "required": true
      },
      "supportsNetworkUploadSpeedTest": {
        "name": "supportsNetworkUploadSpeedTest",
        "type": "boolean",
        "required": true
      },
      "supportsGettingGuestNetworkPassword": {
        "name": "supportsGettingGuestNetworkPassword",
        "type": "boolean",
        "required": true
      }
    },
    states: t.type({
      networkEnabled: t.boolean,
      networkSettings: t.type({
          ssid: t.string,
        }),
      guestNetworkEnabled: t.boolean,
      guestNetworkSettings: t.type({
          ssid: t.string,
        }),
      numConnectedDevices: t.number,
      networkUsageMB: t.number,
      networkUsageLimitMB: t.number,
      networkUsageUnlimited: t.boolean,
    }),
    statesJson: {
      "networkEnabled": {
        "name": "networkEnabled",
        "type": "boolean",
        "required": true
      },
      "networkSettings": {
        "name": "networkSettings",
        "type": "object",
        "required": true,
        "prop": {
          "ssid": {
            "name": "ssid",
            "type": "string",
            "required": true
          }
        }
      },
      "guestNetworkEnabled": {
        "name": "guestNetworkEnabled",
        "type": "boolean",
        "required": true
      },
      "guestNetworkSettings": {
        "name": "guestNetworkSettings",
        "type": "object",
        "required": true,
        "prop": {
          "ssid": {
            "name": "ssid",
            "type": "string",
            "required": true
          }
        }
      },
      "numConnectedDevices": {
        "name": "numConnectedDevices",
        "type": "integer",
        "required": true
      },
      "networkUsageMB": {
        "name": "networkUsageMB",
        "type": "integer",
        "required": true
      },
      "networkUsageLimitMB": {
        "name": "networkUsageLimitMB",
        "type": "integer",
        "required": true
      },
      "networkUsageUnlimited": {
        "name": "networkUsageUnlimited",
        "type": "boolean",
        "required": true
      }
    },
  },
  'action.devices.traits.OnOff': {
    name: 'OnOff',
    type: 'action.devices.traits.OnOff',
    description: 'The basic on and off functionality for any device that has binary on and off, including plugs and switches as well as many future devices.',
    commands: [
      'action.devices.commands.OnOff',
    ],
    attributes: t.type({
      commandOnlyOnOff: t.union([t.boolean, t.undefined]),
      queryOnlyOnOff: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "commandOnlyOnOff": {
        "name": "commandOnlyOnOff",
        "type": "boolean",
        "required": false
      },
      "queryOnlyOnOff": {
        "name": "queryOnlyOnOff",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      on: t.boolean,
    }),
    statesJson: {
      "on": {
        "name": "on",
        "type": "boolean",
        "required": true
      }
    },
  },
  'action.devices.traits.OpenClose': {
    name: 'OpenClose',
    type: 'action.devices.traits.OpenClose',
    description: 'This trait belongs to devices that support opening and closing, and in some cases opening and closing partially or potentially in more than one direction. For example, some blinds may open either to the left or to the right. In some cases, opening certain devices may be a security sensitive action which can require two-factor authentication authentication. See Two-factor authentication.',
    commands: [
      'action.devices.commands.OpenClose',
    ],
    attributes: t.type({
      discreteOnlyOpenClose: t.union([t.boolean, t.undefined]),
      openDirection: t.type({
          UP: t.union([t.string, t.undefined]),
        }),
      queryOnlyOpenClose: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "discreteOnlyOpenClose": {
        "name": "discreteOnlyOpenClose",
        "type": "boolean",
        "required": false
      },
      "openDirection": {
        "name": "openDirection",
        "type": "object",
        "required": true,
        "prop": {
          "UP": {
            "name": "UP",
            "type": "string",
            "required": false
          }
        }
      },
      "queryOnlyOpenClose": {
        "name": "queryOnlyOpenClose",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      openState: t.type({
          openPercent: t.number,
          openDirection: t.string,
        }),
    }),
    statesJson: {
      "openState": {
        "name": "openState",
        "type": "object",
        "required": true,
        "prop": {
          "openPercent": {
            "name": "openPercent",
            "type": "float",
            "required": true
          },
          "openDirection": {
            "name": "openDirection",
            "type": "string",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.Reboot': {
    name: 'Reboot',
    type: 'action.devices.traits.Reboot',
    description: 'This trait belongs to devices that support rebooting, such as routers. The device needs to support rebooting as a single action.',
    commands: [
      'action.devices.commands.Reboot',
    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({    }),
    statesJson: {},
  },
  'action.devices.traits.Rotation': {
    name: 'Rotation',
    type: 'action.devices.traits.Rotation',
    description: 'This trait belongs to devices that support rotation, such as blinds with rotatable slats.',
    commands: [
      'action.devices.commands.RotateAbsolute',
    ],
    attributes: t.type({
      commandOnlyRotation: t.union([t.boolean, t.undefined]),
      supportsContinuousRotation: t.union([t.boolean, t.undefined]),
      supportsDegrees: t.boolean,
      supportsPercent: t.boolean,
      rotationDegreesRange: t.type({
          rotationDegreesMin: t.number,
        }),
    }),
    attributesJson: {
      "commandOnlyRotation": {
        "name": "commandOnlyRotation",
        "type": "boolean",
        "required": false
      },
      "supportsContinuousRotation": {
        "name": "supportsContinuousRotation",
        "type": "boolean",
        "required": false
      },
      "supportsDegrees": {
        "name": "supportsDegrees",
        "type": "boolean",
        "required": true
      },
      "supportsPercent": {
        "name": "supportsPercent",
        "type": "boolean",
        "required": true
      },
      "rotationDegreesRange": {
        "name": "rotationDegreesRange",
        "type": "object",
        "required": true,
        "prop": {
          "rotationDegreesMin": {
            "name": "rotationDegreesMin",
            "type": "float",
            "required": true
          }
        }
      }
    },
    states: t.type({
      rotationPercent: t.number,
      rotationDegrees: t.type({
          rotationDegreesMin: t.number,
        }),
    }),
    statesJson: {
      "rotationPercent": {
        "name": "rotationPercent",
        "type": "float",
        "required": true
      },
      "rotationDegrees": {
        "name": "rotationDegrees",
        "type": "object",
        "required": true,
        "prop": {
          "rotationDegreesMin": {
            "name": "rotationDegreesMin",
            "type": "float",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.RunCycle': {
    name: 'RunCycle',
    type: 'action.devices.traits.RunCycle',
    description: 'This trait represents any device that has an ongoing duration for its operation which can be queried. This includes, but is not limited to, devices that operate cyclically, such as washing machines, dryers, and dishwashers.',
    commands: [

    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({
      currentCycle: t.string,
      nextCycle: t.union([t.string, t.undefined]),
      lang: t.unknown,
      currentTotalRemainingTime: t.number,
      currentCycleRemainingTime: t.number,
    }),
    statesJson: {
      "currentCycle": {
        "name": "currentCycle",
        "type": "object",
        "required": true,
        "prop": "string"
      },
      "nextCycle": {
        "name": "nextCycle",
        "type": "object",
        "required": false,
        "prop": "string"
      },
      "lang": {
        "name": "lang",
        "type": "unknown",
        "required": true
      },
      "currentTotalRemainingTime": {
        "name": "currentTotalRemainingTime",
        "type": "integer",
        "required": true
      },
      "currentCycleRemainingTime": {
        "name": "currentCycleRemainingTime",
        "type": "integer",
        "required": true
      }
    },
  },
  'action.devices.traits.SensorState': {
    name: 'SensorState',
    type: 'action.devices.traits.SensorState',
    description: 'This trait covers both quantitative measurement (for example, air quality index or smoke level) and qualitative state (for example, whether the air quality is healthy or whether the smoke level is low or high).',
    commands: [

    ],
    attributes: t.type({
      sensorStatesSupported: t.array(t.type({
          name: t.string,
          descriptiveCapabilities: t.type({
              'available_states': t.array(t.string),
            }),
          numericCapabilities: t.type({
              rawValueUnit: t.string,
            }),
        })),
    }),
    attributesJson: {
      "sensorStatesSupported": {
        "name": "sensorStatesSupported",
        "type": "array",
        "required": true,
        "prop": {
          "name": {
            "name": "name",
            "type": "string",
            "required": true
          },
          "descriptiveCapabilities": {
            "name": "descriptiveCapabilities",
            "type": "object",
            "required": true,
            "prop": {
              "available_states": {
                "name": "available_states",
                "type": "array",
                "required": true,
                "prop": "string"
              }
            }
          },
          "numericCapabilities": {
            "name": "numericCapabilities",
            "type": "object",
            "required": true,
            "prop": {
              "rawValueUnit": {
                "name": "rawValueUnit",
                "type": "string",
                "required": true
              }
            }
          }
        }
      }
    },
    states: t.type({
      currentSensorStateData: t.array(t.type({
          name: t.string,
          currentSensorState: t.string,
          rawValue: t.number,
        })),
    }),
    statesJson: {
      "currentSensorStateData": {
        "name": "currentSensorStateData",
        "type": "array",
        "required": true,
        "prop": {
          "name": {
            "name": "name",
            "type": "string",
            "required": true
          },
          "currentSensorState": {
            "name": "currentSensorState",
            "type": "string",
            "required": true
          },
          "rawValue": {
            "name": "rawValue",
            "type": "float",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.Scene': {
    name: 'Scene',
    type: 'action.devices.traits.Scene',
    description: 'In the case of scenes, the type maps 1:1 to the trait, as scenes don\'t combine with other traits to form composite devices.',
    commands: [
      'action.devices.commands.ActivateScene',
    ],
    attributes: t.type({
      sceneReversible: t.boolean,
    }),
    attributesJson: {
      "sceneReversible": {
        "name": "sceneReversible",
        "type": "boolean",
        "required": true
      }
    },
    states: t.type({    }),
    statesJson: {},
  },
  'action.devices.traits.SoftwareUpdate': {
    name: 'SoftwareUpdate',
    type: 'action.devices.traits.SoftwareUpdate',
    description: 'This trait belongs to devices that support software updates such as a router. Optionally, these devices may report the time of the last successful update.',
    commands: [
      'action.devices.commands.SoftwareUpdate',
    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({
      lastSoftwareUpdateUnixTimestampSec: t.union([t.number, t.undefined]),
    }),
    statesJson: {
      "lastSoftwareUpdateUnixTimestampSec": {
        "name": "lastSoftwareUpdateUnixTimestampSec",
        "type": "integer",
        "required": false
      }
    },
  },
  'action.devices.traits.StartStop': {
    name: 'StartStop',
    type: 'action.devices.traits.StartStop',
    description: 'Starting and stopping a device serves a similar function to turning it on and off. Devices that inherit this trait function differently when turned on and when started. Unlike devices that simply have an on and off state, some devices that can start and stop are also able to pause while performing operation.',
    commands: [
      'action.devices.commands.StartStop',
      'action.devices.commands.PauseUnpause',
    ],
    attributes: t.type({
      pausable: t.boolean,
      availableZones: t.array(t.string),
    }),
    attributesJson: {
      "pausable": {
        "name": "pausable",
        "type": "boolean",
        "required": true
      },
      "availableZones": {
        "name": "availableZones",
        "type": "array",
        "required": true,
        "prop": "string"
      }
    },
    states: t.type({
      isRunning: t.boolean,
      isPaused: t.type({
          isRunning: t.boolean,
        }),
      activeZones: t.union([t.array(t.string), t.undefined]),
    }),
    statesJson: {
      "isRunning": {
        "name": "isRunning",
        "type": "boolean",
        "required": true
      },
      "isPaused": {
        "name": "isPaused",
        "type": "object",
        "required": true,
        "prop": {
          "isRunning": {
            "name": "isRunning",
            "type": "boolean",
            "required": true
          }
        }
      },
      "activeZones": {
        "name": "activeZones",
        "type": "array",
        "required": false,
        "prop": "string"
      }
    },
  },
  'action.devices.traits.StatusReport': {
    name: 'StatusReport',
    type: 'action.devices.traits.StatusReport',
    description: 'This trait reports the current status or state of a specific device or a connected group of devices.',
    commands: [

    ],
    attributes: t.type({    }),
    attributesJson: {},
    states: t.type({
      currentStatusReport: t.type({
          blocking: t.boolean,
          deviceTarget: t.string,
          priority: t.number,
          statusCode: t.string,
        }),
    }),
    statesJson: {
      "currentStatusReport": {
        "name": "currentStatusReport",
        "type": "object",
        "required": true,
        "prop": {
          "blocking": {
            "name": "blocking",
            "type": "boolean",
            "required": true
          },
          "deviceTarget": {
            "name": "deviceTarget",
            "type": "string",
            "required": true
          },
          "priority": {
            "name": "priority",
            "type": "integer",
            "required": true
          },
          "statusCode": {
            "name": "statusCode",
            "type": "string",
            "required": true
          }
        }
      }
    },
  },
  'action.devices.traits.TemperatureControl': {
    name: 'TemperatureControl',
    type: 'action.devices.traits.TemperatureControl',
    description: 'Trait for devices (other than thermostats) that support controlling temperature, either within or around the device. This includes devices such as ovens and refrigerators.',
    commands: [
      'action.devices.commands.SetTemperature',
    ],
    attributes: t.type({
      temperatureRange: t.type({
          minThresholdCelsius: t.number,
          maxThresholdCelsius: t.number,
        }),
      temperatureStepCelsius: t.union([t.number, t.undefined]),
      temperatureUnitForUX: t.unknown,
      queryOnlyTemperatureControl: t.type({
          temperatureRange: t.union([t.boolean, t.undefined]),
        }),
      commandOnlyTemperatureControl: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "temperatureRange": {
        "name": "temperatureRange",
        "type": "object",
        "required": true,
        "prop": {
          "minThresholdCelsius": {
            "name": "minThresholdCelsius",
            "type": "float",
            "required": true
          },
          "maxThresholdCelsius": {
            "name": "maxThresholdCelsius",
            "type": "float",
            "required": true
          }
        }
      },
      "temperatureStepCelsius": {
        "name": "temperatureStepCelsius",
        "type": "float",
        "required": false
      },
      "temperatureUnitForUX": {
        "name": "temperatureUnitForUX",
        "type": "unknown",
        "required": true
      },
      "queryOnlyTemperatureControl": {
        "name": "queryOnlyTemperatureControl",
        "type": "object",
        "required": true,
        "prop": {
          "temperatureRange": {
            "name": "temperatureRange",
            "type": "boolean",
            "required": false
          }
        }
      },
      "commandOnlyTemperatureControl": {
        "name": "commandOnlyTemperatureControl",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      temperatureSetpointCelsius: t.number,
      temperatureAmbientCelsius: t.union([t.number, t.undefined]),
    }),
    statesJson: {
      "temperatureSetpointCelsius": {
        "name": "temperatureSetpointCelsius",
        "type": "float",
        "required": true
      },
      "temperatureAmbientCelsius": {
        "name": "temperatureAmbientCelsius",
        "type": "float",
        "required": false
      }
    },
  },
  'action.devices.traits.TemperatureSetting': {
    name: 'TemperatureSetting',
    type: 'action.devices.traits.TemperatureSetting',
    description: 'This trait covers handling both temperature point and modes.',
    commands: [
      'action.devices.commands.ThermostatTemperatureSetpoint',
      'action.devices.commands.ThermostatTemperatureSetRange',
      'action.devices.commands.ThermostatSetMode',
      'action.devices.commands.TemperatureRelative',
    ],
    attributes: t.type({
      availableThermostatModes: t.array(t.type({
          off: t.unknown,
          heat: t.unknown,
          cool: t.unknown,
          on: t.unknown,
          heatcool: t.unknown,
          auto: t.unknown,
          'fan-only': t.unknown,
          purifier: t.unknown,
          eco: t.unknown,
          dry: t.unknown,
        })),
      thermostatTemperatureRange: t.union([t.type({
          minThresholdCelsius: t.unknown,
          maxThresholdCelsius: t.unknown,
        }), t.undefined]),
      thermostatTemperatureUnit: t.type({
          C: t.unknown,
        }),
      bufferRangeCelsius: t.type({
          heatcool: t.union([t.unknown, t.undefined]),
        }),
      commandOnlyTemperatureSetting: t.union([t.boolean, t.undefined]),
      queryOnlyTemperatureSetting: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "availableThermostatModes": {
        "name": "availableThermostatModes",
        "type": "array",
        "required": true,
        "prop": {
          "off": {
            "name": "off",
            "type": "unknown",
            "required": true
          },
          "heat": {
            "name": "heat",
            "type": "unknown",
            "required": true
          },
          "cool": {
            "name": "cool",
            "type": "unknown",
            "required": true
          },
          "on": {
            "name": "on",
            "type": "unknown",
            "required": true
          },
          "heatcool": {
            "name": "heatcool",
            "type": "unknown",
            "required": true
          },
          "auto": {
            "name": "auto",
            "type": "unknown",
            "required": true
          },
          "fan-only": {
            "name": "fan-only",
            "type": "unknown",
            "required": true
          },
          "purifier": {
            "name": "purifier",
            "type": "unknown",
            "required": true
          },
          "eco": {
            "name": "eco",
            "type": "unknown",
            "required": true
          },
          "dry": {
            "name": "dry",
            "type": "unknown",
            "required": true
          }
        }
      },
      "thermostatTemperatureRange": {
        "name": "thermostatTemperatureRange",
        "type": "object",
        "required": false,
        "prop": {
          "minThresholdCelsius": {
            "name": "minThresholdCelsius",
            "type": "unknown",
            "required": true
          },
          "maxThresholdCelsius": {
            "name": "maxThresholdCelsius",
            "type": "unknown",
            "required": true
          }
        }
      },
      "thermostatTemperatureUnit": {
        "name": "thermostatTemperatureUnit",
        "type": "object",
        "required": true,
        "prop": {
          "C": {
            "name": "C",
            "type": "unknown",
            "required": true
          }
        }
      },
      "bufferRangeCelsius": {
        "name": "bufferRangeCelsius",
        "type": "object",
        "required": true,
        "prop": {
          "heatcool": {
            "name": "heatcool",
            "type": "unknown",
            "required": false
          }
        }
      },
      "commandOnlyTemperatureSetting": {
        "name": "commandOnlyTemperatureSetting",
        "type": "boolean",
        "required": false
      },
      "queryOnlyTemperatureSetting": {
        "name": "queryOnlyTemperatureSetting",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      activeThermostatMode: t.type({
          availableThermostatModes: t.union([t.string, t.undefined]),
        }),
      targetTempReachedEstimateUnixTimestampSec: t.union([t.unknown, t.undefined]),
      thermostatHumidityAmbient: t.number,
      thermostatMode: t.unknown,
      thermostatTemperatureAmbient: t.unknown,
      thermostatTemperatureSetpoint: t.unknown,
      thermostatTemperatureSetpointHigh: t.unknown,
      thermostatTemperatureSetpointLow: t.unknown,
    }),
    statesJson: {
      "activeThermostatMode": {
        "name": "activeThermostatMode",
        "type": "object",
        "required": true,
        "prop": {
          "availableThermostatModes": {
            "name": "availableThermostatModes",
            "type": "string",
            "required": false
          }
        }
      },
      "targetTempReachedEstimateUnixTimestampSec": {
        "name": "targetTempReachedEstimateUnixTimestampSec",
        "type": "unknown",
        "required": false
      },
      "thermostatHumidityAmbient": {
        "name": "thermostatHumidityAmbient",
        "type": "float",
        "required": true
      },
      "thermostatMode": {
        "name": "thermostatMode",
        "type": "unknown",
        "required": true
      },
      "thermostatTemperatureAmbient": {
        "name": "thermostatTemperatureAmbient",
        "type": "unknown",
        "required": true
      },
      "thermostatTemperatureSetpoint": {
        "name": "thermostatTemperatureSetpoint",
        "type": "unknown",
        "required": true
      },
      "thermostatTemperatureSetpointHigh": {
        "name": "thermostatTemperatureSetpointHigh",
        "type": "unknown",
        "required": true
      },
      "thermostatTemperatureSetpointLow": {
        "name": "thermostatTemperatureSetpointLow",
        "type": "unknown",
        "required": true
      }
    },
  },
  'action.devices.traits.Timer': {
    name: 'Timer',
    type: 'action.devices.traits.Timer',
    description: 'The Timer trait represents a timer on a device, primarily kitchen appliances such as ovens and microwaves, but not limited to them.',
    commands: [
      'action.devices.commands.TimerStart',
      'action.devices.commands.TimerAdjust',
      'action.devices.commands.TimerPause',
      'action.devices.commands.TimerResume',
      'action.devices.commands.TimerCancel',
    ],
    attributes: t.type({
      maxTimerLimitSec: t.number,
      commandOnlyTimer: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "maxTimerLimitSec": {
        "name": "maxTimerLimitSec",
        "type": "integer",
        "required": true
      },
      "commandOnlyTimer": {
        "name": "commandOnlyTimer",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      timerRemainingSec: t.type({
          maxTimerLimitSec: t.number,
        }),
      timerPaused: t.union([t.boolean, t.undefined]),
    }),
    statesJson: {
      "timerRemainingSec": {
        "name": "timerRemainingSec",
        "type": "object",
        "required": true,
        "prop": {
          "maxTimerLimitSec": {
            "name": "maxTimerLimitSec",
            "type": "integer",
            "required": true
          }
        }
      },
      "timerPaused": {
        "name": "timerPaused",
        "type": "boolean",
        "required": false
      }
    },
  },
  'action.devices.traits.Toggles': {
    name: 'Toggles',
    type: 'action.devices.traits.Toggles',
    description: 'This trait belongs to any devices with settings that can only exist in one of two states. These settings can represent a physical button with an on/off or active/inactive state, a checkbox in HTML, or any other sort of specifically enabled/disabled element.',
    commands: [
      'action.devices.commands.SetToggles',
    ],
    attributes: t.type({
      availableToggles: t.type({
          name: t.string,
          'name_values': t.unknown,
        }),
      commandOnlyToggles: t.union([t.boolean, t.undefined]),
    }),
    attributesJson: {
      "availableToggles": {
        "name": "availableToggles",
        "type": "object",
        "required": true,
        "prop": {
          "name": {
            "name": "name",
            "type": "string",
            "required": true
          },
          "name_values": {
            "name": "name_values",
            "type": "unknown",
            "required": true
          }
        }
      },
      "commandOnlyToggles": {
        "name": "commandOnlyToggles",
        "type": "boolean",
        "required": false
      }
    },
    states: t.type({
      currentToggleSettings: t.array(t.undefined),
    }),
    statesJson: {
      "currentToggleSettings": {
        "name": "currentToggleSettings",
        "type": "array",
        "required": true
      }
    },
  },
  'action.devices.traits.TransportControl': {
    name: 'TransportControl',
    type: 'action.devices.traits.TransportControl',
    description: 'This trait supports media devices which are able to control media playback (for example, resuming music that\'s paused).',
    commands: [
      'isOn',
      'isSingle',
    ],
    attributes: t.type({
      transportControlSupportedCommands: t.array(t.type({
          'CAPTION_CONTROL': t.unknown,
          NEXT: t.unknown,
          PAUSE: t.unknown,
          PREVIOUS: t.unknown,
          RESUME: t.unknown,
          'SEEK_RELATIVE': t.unknown,
          'SEEK_TO_POSITION': t.unknown,
          'SET_REPEAT': t.unknown,
          SHUFFLE: t.unknown,
          STOP: t.unknown,
        })),
    }),
    attributesJson: {
      "transportControlSupportedCommands": {
        "name": "transportControlSupportedCommands",
        "type": "array",
        "required": true,
        "prop": {
          "CAPTION_CONTROL": {
            "name": "CAPTION_CONTROL",
            "type": "unknown",
            "required": true
          },
          "NEXT": {
            "name": "NEXT",
            "type": "unknown",
            "required": true
          },
          "PAUSE": {
            "name": "PAUSE",
            "type": "unknown",
            "required": true
          },
          "PREVIOUS": {
            "name": "PREVIOUS",
            "type": "unknown",
            "required": true
          },
          "RESUME": {
            "name": "RESUME",
            "type": "unknown",
            "required": true
          },
          "SEEK_RELATIVE": {
            "name": "SEEK_RELATIVE",
            "type": "unknown",
            "required": true
          },
          "SEEK_TO_POSITION": {
            "name": "SEEK_TO_POSITION",
            "type": "unknown",
            "required": true
          },
          "SET_REPEAT": {
            "name": "SET_REPEAT",
            "type": "unknown",
            "required": true
          },
          "SHUFFLE": {
            "name": "SHUFFLE",
            "type": "unknown",
            "required": true
          },
          "STOP": {
            "name": "STOP",
            "type": "unknown",
            "required": true
          }
        }
      }
    },
    states: t.type({    }),
    statesJson: {},
  },
  'action.devices.traits.Volume': {
    name: 'Volume',
    type: 'action.devices.traits.Volume',
    description: 'This trait belongs to devices which are able to change volume (for example, setting the volume to a certain level, mute, or unmute).',
    commands: [
      'relativeSteps',
    ],
    attributes: t.type({
      volumeMaxLevel: t.number,
      volumeCanMuteAndUnmute: t.boolean,
      volumeDefaultPercentage: t.number,
      levelStepSize: t.number,
      commandOnlyVolume: t.boolean,
    }),
    attributesJson: {
      "volumeMaxLevel": {
        "name": "volumeMaxLevel",
        "type": "integer",
        "required": true
      },
      "volumeCanMuteAndUnmute": {
        "name": "volumeCanMuteAndUnmute",
        "type": "boolean",
        "required": true
      },
      "volumeDefaultPercentage": {
        "name": "volumeDefaultPercentage",
        "type": "integer",
        "required": true
      },
      "levelStepSize": {
        "name": "levelStepSize",
        "type": "integer",
        "required": true
      },
      "commandOnlyVolume": {
        "name": "commandOnlyVolume",
        "type": "boolean",
        "required": true
      }
    },
    states: t.type({
      currentVolume: t.number,
      isMuted: t.boolean,
    }),
    statesJson: {
      "currentVolume": {
        "name": "currentVolume",
        "type": "integer",
        "required": true
      },
      "isMuted": {
        "name": "isMuted",
        "type": "boolean",
        "required": true
      }
    },
  },
};

export const CommandTypeInformation = {
  'action.devices.commands.appInstall': {
    type: 'action.devices.commands.appInstall',
    typeObject: t.type({
      newApplication: t.string,
      newApplicationName: t.string,
    })
  },
  'action.devices.commands.appSearch': {
    type: 'action.devices.commands.appSearch',
    typeObject: t.type({
      newApplication: t.string,
      newApplicationName: t.string,
    })
  },
  'action.devices.commands.appSelect': {
    type: 'action.devices.commands.appSelect',
    typeObject: t.type({
      newApplication: t.string,
      newApplicationName: t.string,
    })
  },
  'action.devices.commands.ArmDisarm': {
    type: 'action.devices.commands.ArmDisarm',
    typeObject: t.type({
    arm: t.boolean,
    cancel: t.boolean,
    armLevel: t.string,
  })
  },
  'action.devices.commands.BrightnessAbsolute': {
    type: 'action.devices.commands.BrightnessAbsolute',
    typeObject: t.type({
    brightness: t.number,
  })
  },
  'action.devices.commands.GetCameraStream': {
    type: 'action.devices.commands.GetCameraStream',
    typeObject: t.union([t.string, t.undefined])
  },
  'action.devices.commands.ColorAbsolute': {
    type: 'action.devices.commands.ColorAbsolute',
    typeObject: t.type({
    name: t.union([t.string, t.undefined]),
  })
  },
  'action.devices.commands.Cook': {
    type: 'action.devices.commands.Cook',
    typeObject: t.type({
    start: t.boolean,
    cookingMode: t.union([t.string, t.undefined]),
    foodPreset: t.union([t.string, t.undefined]),
    quantity: t.union([t.number, t.undefined]),
    unit: t.union([t.string, t.undefined]),
  })
  },
  'action.devices.commands.Dispense': {
    type: 'action.devices.commands.Dispense',
    typeObject: t.unknown
  },
  'action.devices.commands.Dock': {
    type: 'action.devices.commands.Dock',
    typeObject: t.unknown
  },
  'action.devices.commands.Charge': {
    type: 'action.devices.commands.Charge',
    typeObject: t.type({
    charge: t.boolean,
  })
  },
  'action.devices.commands.SetFanSpeed': {
    type: 'action.devices.commands.SetFanSpeed',
    typeObject: t.type({
    fanSpeed: t.string,
    fanSpeedPercent: t.number,
  })
  },
  'action.devices.commands.SetFanSpeedRelativeSpeed': {
    type: 'action.devices.commands.SetFanSpeedRelativeSpeed',
    typeObject: t.type({
    fanSpeedRelativeWeight: t.number,
    fanSpeedRelativePercent: t.number,
  })
  },
  'action.devices.commands.Reverse': {
    type: 'action.devices.commands.Reverse',
    typeObject: t.unknown
  },
  'action.devices.commands.Fill': {
    type: 'action.devices.commands.Fill',
    typeObject: t.union([t.boolean, t.undefined])
  },
  'action.devices.commands.SetHumidity': {
    type: 'action.devices.commands.SetHumidity',
    typeObject: t.number
  },
  'action.devices.commands.HumidityRelative': {
    type: 'action.devices.commands.HumidityRelative',
    typeObject: t.type({
    humidityRelativePercent: t.number,
    humidityRelativeWeight: t.number,
  })
  },
  'action.devices.commands.SetInput': {
    type: 'action.devices.commands.SetInput',
    typeObject: t.type({
      newInput: t.string,
    })
  },
  'action.devices.commands.ColorLoop': {
    type: 'action.devices.commands.ColorLoop',
    typeObject: t.unknown
  },
  'action.devices.commands.Sleep': {
    type: 'action.devices.commands.Sleep',
    typeObject: t.union([t.type({
    duration: t.union([t.number, t.undefined]),
  }), t.undefined])
  },
  'action.devices.commands.StopEffect': {
    type: 'action.devices.commands.StopEffect',
    typeObject: t.unknown
  },
  'action.devices.commands.Wake': {
    type: 'action.devices.commands.Wake',
    typeObject: t.union([t.type({
    duration: t.union([t.number, t.undefined]),
  }), t.undefined])
  },
  'action.devices.commands.Locate': {
    type: 'action.devices.commands.Locate',
    typeObject: t.type({
    silence: t.boolean,
  })
  },
  'action.devices.commands.LockUnlock': {
    type: 'action.devices.commands.LockUnlock',
    typeObject: t.type({
    lock: t.boolean,
  })
  },
  'action.devices.commands.SetModes': {
    type: 'action.devices.commands.SetModes',
    typeObject: t.string
  },
  'action.devices.commands.EnableDisableGuestNetwork': {
    type: 'action.devices.commands.EnableDisableGuestNetwork',
    typeObject: t.type({
      enable: t.boolean,
    })
  },
  'action.devices.commands.EnableDisableNetworkProfile': {
    type: 'action.devices.commands.EnableDisableNetworkProfile',
    typeObject: t.type({
      profile: t.string,
      enable: t.boolean,
    })
  },
  'action.devices.commands.GetGuestNetworkPassword': {
    type: 'action.devices.commands.GetGuestNetworkPassword',
    typeObject: t.type({
      guestNetworkPassword: t.string,
    })
  },
  'action.devices.commands.TestNetworkSpeed': {
    type: 'action.devices.commands.TestNetworkSpeed',
    typeObject: t.type({
      testDownloadSpeed: t.boolean,
      testUploadSpeed: t.boolean,
    })
  },
  'action.devices.commands.OnOff': {
    type: 'action.devices.commands.OnOff',
    typeObject: t.type({
    on: t.boolean,
  })
  },
  'action.devices.commands.OpenClose': {
    type: 'action.devices.commands.OpenClose',
    typeObject: t.union([t.number, t.undefined])
  },
  'action.devices.commands.Reboot': {
    type: 'action.devices.commands.Reboot',
    typeObject: t.unknown
  },
  'action.devices.commands.RotateAbsolute': {
    type: 'action.devices.commands.RotateAbsolute',
    typeObject: t.number
  },
  'action.devices.commands.ActivateScene': {
    type: 'action.devices.commands.ActivateScene',
    typeObject: t.type({
    deactivate: t.boolean,
  })
  },
  'action.devices.commands.SoftwareUpdate': {
    type: 'action.devices.commands.SoftwareUpdate',
    typeObject: t.unknown
  },
  'action.devices.commands.StartStop': {
    type: 'action.devices.commands.StartStop',
    typeObject: t.union([t.boolean, t.undefined])
  },
  'action.devices.commands.PauseUnpause': {
    type: 'action.devices.commands.PauseUnpause',
    typeObject: t.boolean
  },
  'action.devices.commands.SetTemperature': {
    type: 'action.devices.commands.SetTemperature',
    typeObject: t.type({
    temperature: t.number,
  })
  },
  'action.devices.commands.ThermostatTemperatureSetpoint': {
    type: 'action.devices.commands.ThermostatTemperatureSetpoint',
    typeObject: t.type({
    thermostatTemperatureSetpoint: t.number,
  })
  },
  'action.devices.commands.ThermostatTemperatureSetRange': {
    type: 'action.devices.commands.ThermostatTemperatureSetRange',
    typeObject: t.type({
    thermostatTemperatureSetpointHigh: t.number,
  })
  },
  'action.devices.commands.ThermostatSetMode': {
    type: 'action.devices.commands.ThermostatSetMode',
    typeObject: t.type({
    thermostatMode: t.unknown,
  })
  },
  'action.devices.commands.TemperatureRelative': {
    type: 'action.devices.commands.TemperatureRelative',
    typeObject: t.type({
    thermostatTemperatureRelativeDegree: t.number,
    thermostatTemperatureRelativeWeight: t.number,
  })
  },
  'action.devices.commands.TimerStart': {
    type: 'action.devices.commands.TimerStart',
    typeObject: t.number
  },
  'action.devices.commands.TimerAdjust': {
    type: 'action.devices.commands.TimerAdjust',
    typeObject: t.number
  },
  'action.devices.commands.TimerPause': {
    type: 'action.devices.commands.TimerPause',
    typeObject: t.type({
    timerRemainingSec: t.unknown,
    noTimerExists: t.unknown,
  })
  },
  'action.devices.commands.TimerResume': {
    type: 'action.devices.commands.TimerResume',
    typeObject: t.type({
    timerRemainingSec: t.unknown,
    noTimerExists: t.unknown,
  })
  },
  'action.devices.commands.TimerCancel': {
    type: 'action.devices.commands.TimerCancel',
    typeObject: t.type({
    timerRemainingSec: t.unknown,
    noTimerExists: t.unknown,
  })
  },
  'action.devices.commands.SetToggles': {
    type: 'action.devices.commands.SetToggles',
    typeObject: t.boolean
  },
  isOn: {
    type: 'isOn',
    typeObject: t.boolean
  },
  isSingle: {
    type: 'isSingle',
    typeObject: t.boolean
  },
  relativeSteps: {
    type: 'relativeSteps',
    typeObject: t.number
  },
};

export type AppSelectorTraitTypeAttributes = {
  availableApplications: Array<{
      key: string;
      names: Array<{
          'name_synonym': Array<string>;
          lang: string;
        }>;
    }>;
};
export type AppSelectorTraitTypeStates = {
  currentApplication: string;
};
export type AppInstallCommandType = TraitCommandType<'action.devices.commands.appInstall', {
  newApplication: string;
  newApplicationName: string;
}>;
export type AppSearchCommandType = TraitCommandType<'action.devices.commands.appSearch', {
  newApplication: string;
  newApplicationName: string;
}>;
export type AppSelectCommandType = TraitCommandType<'action.devices.commands.appSelect', {
  newApplication: string;
  newApplicationName: string;
}>;
export type AppSelectorTraitTypeCommands = AppInstallCommandType
  | AppSearchCommandType
  | AppSelectCommandType;
export type AppSelectorTraitType = TraitType<
  AppSelectorTraitTypeAttributes,
  AppSelectorTraitTypeStates,
  AppSelectorTraitTypeCommands>;
export type ArmDisarmTraitTypeAttributes = {
  availableArmLevels: {
      levels: Array<{
          'level_name': string;
          'level_values': Array<{
              'level_synonym': Array<string>;
              lang: string;
            }>;
        }>;
      ordered: boolean;
    } | undefined;
};
export type ArmDisarmTraitTypeStates = {
  isArmed: boolean;
  currentArmLevel: {
      availableArmLevels: string;
    };
  currentStatusReport: unknown | undefined;
  exitAllowance: number | undefined;
};
export type ArmDisarmCommandType = TraitCommandType<'action.devices.commands.ArmDisarm', {
    arm: boolean;
    cancel: boolean;
    armLevel: string;
  }>;
export type ArmDisarmTraitTypeCommands = ArmDisarmCommandType;
export type ArmDisarmTraitType = TraitType<
  ArmDisarmTraitTypeAttributes,
  ArmDisarmTraitTypeStates,
  ArmDisarmTraitTypeCommands>;
export type BrightnessTraitTypeAttributes = {
  commandOnlyBrightness: boolean | undefined;
};
export type BrightnessTraitTypeStates = {
  brightness: number;
};
export type BrightnessAbsoluteCommandType = TraitCommandType<'action.devices.commands.BrightnessAbsolute', {
    brightness: number;
  }>;
export type BrightnessTraitTypeCommands = BrightnessAbsoluteCommandType;
export type BrightnessTraitType = TraitType<
  BrightnessTraitTypeAttributes,
  BrightnessTraitTypeStates,
  BrightnessTraitTypeCommands>;
export type CameraStreamTraitTypeAttributes = {
  cameraStreamSupportedProtocols: Array<string>;
  cameraStreamNeedAuthToken: boolean;
  cameraStreamNeedDrmEncryption: boolean;
};
export type CameraStreamTraitTypeStates = {};
export type GetCameraStreamCommandType = TraitCommandType<'action.devices.commands.GetCameraStream', string | undefined>;
export type CameraStreamTraitTypeCommands = GetCameraStreamCommandType;
export type CameraStreamTraitType = TraitType<
  CameraStreamTraitTypeAttributes,
  CameraStreamTraitTypeStates,
  CameraStreamTraitTypeCommands>;
export type ColorSettingTraitTypeAttributes = {
  colorModel: string;
  colorTemperatureRange: {
      temperatureMinK: number;
      temperatureMaxK: number;
    };
  commandOnlyColorSetting: boolean | undefined;
};
export type ColorSettingTraitTypeStates = {
  color: {
      temperatureK: number;
      spectrumRgb: number;
      spectrumHsv: {
          hue: number;
          saturation: number;
          value: number;
        };
    };
};
export type ColorAbsoluteCommandType = TraitCommandType<'action.devices.commands.ColorAbsolute', {
    name: string | undefined;
  }>;
export type ColorSettingTraitTypeCommands = ColorAbsoluteCommandType;
export type ColorSettingTraitType = TraitType<
  ColorSettingTraitTypeAttributes,
  ColorSettingTraitTypeStates,
  ColorSettingTraitTypeCommands>;
export type ColorSpectrumTraitTypeAttributes = {
  colorModel: {
      hsv: string | undefined;
    };
};
export type ColorSpectrumTraitTypeStates = {
  color: {
      name: string;
      spectrumRGB: number;
    };
};
export type ColorSpectrumTraitTypeCommands = undefined;
export type ColorSpectrumTraitType = TraitType<
  ColorSpectrumTraitTypeAttributes,
  ColorSpectrumTraitTypeStates,
  ColorSpectrumTraitTypeCommands>;
export type ColorTemperatureTraitTypeAttributes = {
  temperatureMinK: {
      temperatureMaxK: unknown | undefined;
    };
  temperatureMaxK: {
      temperatureMinK: unknown | undefined;
    };
};
export type ColorTemperatureTraitTypeStates = {
  color: {
      name: string;
      temperature: number;
    };
};
export type ColorTemperatureTraitTypeCommands = undefined;
export type ColorTemperatureTraitType = TraitType<
  ColorTemperatureTraitTypeAttributes,
  ColorTemperatureTraitTypeStates,
  ColorTemperatureTraitTypeCommands>;
export type CookTraitTypeAttributes = {
  supportedCookingModes: string;
  foodPresets: Array<{
      'food_preset_name': string;
      'supported_units': Array<string>;
      'food_synonyms': Array<{
          synonym: Array<string>;
          lang: string;
        }>;
    }> | undefined;
};
export type CookTraitTypeStates = {
  currentCookingMode: {
      NONE: string;
    };
  currentFoodPreset: {
      foodPresets: string | undefined;
    };
  currentFoodQuantity: {
      currentFoodUnit: number | undefined;
    };
  currentFoodUnit: {
      currentFoodQuantity: string | undefined;
    };
};
export type CookCommandType = TraitCommandType<'action.devices.commands.Cook', {
    start: boolean;
    cookingMode: string | undefined;
    foodPreset: string | undefined;
    quantity: number | undefined;
    unit: string | undefined;
  }>;
export type CookTraitTypeCommands = CookCommandType;
export type CookTraitType = TraitType<
  CookTraitTypeAttributes,
  CookTraitTypeStates,
  CookTraitTypeCommands>;
export type DispenseTraitTypeAttributes = {
  supportedDispenseItems: Array<{
      'item_name': string;
      'item_name_synonyms': Array<{
          lang: string;
          synonyms: Array<string>;
        }>;
      'supported_units': Array<string>;
      'default_portion': {
          amount: number;
          unit: string;
        };
    }>;
};
export type DispenseTraitTypeStates = {
  dispenseItems: Array<{
      itemName: string | undefined;
      amountRemaining: {
          amount: number;
          unit: string;
        } | undefined;
      amountLastDispensed: {
          amount: number;
          unit: string;
        } | undefined;
      isCurrentlyDispensing: boolean | undefined;
    }> | undefined;
};
export type DispenseCommandType = TraitCommandType<'action.devices.commands.Dispense', unknown>;
export type DispenseTraitTypeCommands = DispenseCommandType;
export type DispenseTraitType = TraitType<
  DispenseTraitTypeAttributes,
  DispenseTraitTypeStates,
  DispenseTraitTypeCommands>;
export type DockTraitTypeAttributes = {};
export type DockTraitTypeStates = {
  isDocked: unknown;
};
export type DockCommandType = TraitCommandType<'action.devices.commands.Dock', unknown>;
export type DockTraitTypeCommands = DockCommandType;
export type DockTraitType = TraitType<
  DockTraitTypeAttributes,
  DockTraitTypeStates,
  DockTraitTypeCommands>;
export type EnergyStorageTraitTypeAttributes = {
  queryOnlyEnergyStorage: {
      isRechargeable: boolean | undefined;
    };
  energyStorageDistanceUnitForUX: string;
  isRechargeable: boolean | undefined;
};
export type EnergyStorageTraitTypeStates = {
  descriptiveCapacityRemaining: string;
  capacityRemaining: Array<{    }>;
};
export type ChargeCommandType = TraitCommandType<'action.devices.commands.Charge', {
    charge: boolean;
  }>;
export type EnergyStorageTraitTypeCommands = ChargeCommandType;
export type EnergyStorageTraitType = TraitType<
  EnergyStorageTraitTypeAttributes,
  EnergyStorageTraitTypeStates,
  EnergyStorageTraitTypeCommands>;
export type FanSpeedTraitTypeAttributes = {
  availableFanSpeeds: {
      speeds: Array<{
          'speed_name': string;
          'speed_values': unknown;
        }>;
      ordered: boolean;
    };
  reversible: boolean;
  supportsFanSpeedPercent: boolean;
  commandOnlyFanSpeed: boolean | undefined;
};
export type FanSpeedTraitTypeStates = {
  currentFanSpeedSetting: {
      'action.devices.traits.FanSpeed': string;
    };
  currentFanSpeedPercent: number;
};
export type SetFanSpeedCommandType = TraitCommandType<'action.devices.commands.SetFanSpeed', {
    fanSpeed: string;
    fanSpeedPercent: number;
  }>;
export type SetFanSpeedRelativeSpeedCommandType = TraitCommandType<'action.devices.commands.SetFanSpeedRelativeSpeed', {
    fanSpeedRelativeWeight: number;
    fanSpeedRelativePercent: number;
  }>;
export type ReverseCommandType = TraitCommandType<'action.devices.commands.Reverse', unknown>;
export type FanSpeedTraitTypeCommands = SetFanSpeedCommandType
  | SetFanSpeedRelativeSpeedCommandType
  | ReverseCommandType;
export type FanSpeedTraitType = TraitType<
  FanSpeedTraitTypeAttributes,
  FanSpeedTraitTypeStates,
  FanSpeedTraitTypeCommands>;
export type FillTraitTypeAttributes = {
  availableFillLevels: {
      levels: Array<{
          'level_name': string;
          'level_values': unknown;
          'level_synonym': Array<string>;
        }>;
      ordered: boolean;
    } | undefined;
};
export type FillTraitTypeStates = {
  isFilled: {
      levels: boolean;
    };
  currentFillLevel: {
      availableFillLevels: string;
    };
};
export type FillCommandType = TraitCommandType<'action.devices.commands.Fill', boolean | undefined>;
export type FillTraitTypeCommands = FillCommandType;
export type FillTraitType = TraitType<
  FillTraitTypeAttributes,
  FillTraitTypeStates,
  FillTraitTypeCommands>;
export type HumiditySettingTraitTypeAttributes = {
  humiditySetpointRange: {
      minPercent: number | undefined;
      maxPercent: number | undefined;
    } | undefined;
  commandOnlyHumiditySetting: boolean | undefined;
  queryOnlyHumiditySetting: boolean | undefined;
};
export type HumiditySettingTraitTypeStates = {
  humiditySetpointPercent: {
      minHumidityPercent: number | undefined;
    };
  humidityAmbientPercent: number | undefined;
};
export type SetHumidityCommandType = TraitCommandType<'action.devices.commands.SetHumidity', number>;
export type HumidityRelativeCommandType = TraitCommandType<'action.devices.commands.HumidityRelative', {
    humidityRelativePercent: number;
    humidityRelativeWeight: number;
  }>;
export type HumiditySettingTraitTypeCommands = SetHumidityCommandType
  | HumidityRelativeCommandType;
export type HumiditySettingTraitType = TraitType<
  HumiditySettingTraitTypeAttributes,
  HumiditySettingTraitTypeStates,
  HumiditySettingTraitTypeCommands>;
export type InputSelectorTraitTypeAttributes = {
  availableInputs: Array<{
      key: string;
      names: Array<{
          lang: string;
          'name_synonym': Array<string>;
        }>;
    }>;
  commandOnlyInputSelector: boolean;
  orderedInputs: boolean;
};
export type InputSelectorTraitTypeStates = {
  currentInput: string;
};
export type SetInputCommandType = TraitCommandType<'action.devices.commands.SetInput', {
  newInput: string;
}>;
export type InputSelectorTraitTypeCommands = SetInputCommandType;
export type InputSelectorTraitType = TraitType<
  InputSelectorTraitTypeAttributes,
  InputSelectorTraitTypeStates,
  InputSelectorTraitTypeCommands>;
export type LightEffectsTraitTypeAttributes = {
  defaultSleepDuration: {
      'action.devices.commands.Sleep': number | undefined;
    };
  defaultWakeDuration: {
      'action.devices.commands.Wake': number | undefined;
    };
  supportedEffects: Array<{
      colorLoop: unknown;
      sleep: unknown | undefined;
      wake: unknown | undefined;
    }>;
};
export type LightEffectsTraitTypeStates = {
  activeLightEffect: string | undefined;
};
export type ColorLoopCommandType = TraitCommandType<'action.devices.commands.ColorLoop', unknown>;
export type SleepCommandType = TraitCommandType<'action.devices.commands.Sleep', {
    duration: number | undefined;
  } | undefined>;
export type StopEffectCommandType = TraitCommandType<'action.devices.commands.StopEffect', unknown>;
export type WakeCommandType = TraitCommandType<'action.devices.commands.Wake', {
    duration: number | undefined;
  } | undefined>;
export type LightEffectsTraitTypeCommands = ColorLoopCommandType
  | SleepCommandType
  | StopEffectCommandType
  | WakeCommandType;
export type LightEffectsTraitType = TraitType<
  LightEffectsTraitTypeAttributes,
  LightEffectsTraitTypeStates,
  LightEffectsTraitTypeCommands>;
export type LocatorTraitTypeAttributes = {};
export type LocatorTraitTypeStates = {};
export type LocateCommandType = TraitCommandType<'action.devices.commands.Locate', {
    silence: boolean;
  }>;
export type LocatorTraitTypeCommands = LocateCommandType;
export type LocatorTraitType = TraitType<
  LocatorTraitTypeAttributes,
  LocatorTraitTypeStates,
  LocatorTraitTypeCommands>;
export type LockUnlockTraitTypeAttributes = {};
export type LockUnlockTraitTypeStates = {
  isLocked: boolean;
  isJammed: boolean;
};
export type LockUnlockCommandType = TraitCommandType<'action.devices.commands.LockUnlock', {
    lock: boolean;
  }>;
export type LockUnlockTraitTypeCommands = LockUnlockCommandType;
export type LockUnlockTraitType = TraitType<
  LockUnlockTraitTypeAttributes,
  LockUnlockTraitTypeStates,
  LockUnlockTraitTypeCommands>;
export type MediaStateTraitTypeAttributes = {
  supportActivityState: boolean;
  supportPlaybackState: boolean;
};
export type MediaStateTraitTypeStates = {
  activityState: string;
  playbackState: string;
};
export type MediaStateTraitTypeCommands = undefined;
export type MediaStateTraitType = TraitType<
  MediaStateTraitTypeAttributes,
  MediaStateTraitTypeStates,
  MediaStateTraitTypeCommands>;
export type ModesTraitTypeAttributes = {
  availableModes: {
      name: string;
      'name_values': unknown;
      settings: unknown;
      ordered: Array<unknown>;
    };
  commandOnlyModes: boolean | undefined;
};
export type ModesTraitTypeStates = {
  currentModeSettings: string;
};
export type SetModesCommandType = TraitCommandType<'action.devices.commands.SetModes', string>;
export type ModesTraitTypeCommands = SetModesCommandType;
export type ModesTraitType = TraitType<
  ModesTraitTypeAttributes,
  ModesTraitTypeStates,
  ModesTraitTypeCommands>;
export type NetworkControlTraitTypeAttributes = {
  supportsEnablingGuestNetwork: boolean;
  supportsDisablingGuestNetwork: boolean;
  networkProfiles: Array<string>;
  supportsEnablingNetworkProfile: boolean;
  supportsDisablingNetworkProfile: boolean;
  supportsNetworkDownloadSpeedTest: boolean;
  supportsNetworkUploadSpeedTest: boolean;
  supportsGettingGuestNetworkPassword: boolean;
};
export type NetworkControlTraitTypeStates = {
  networkEnabled: boolean;
  networkSettings: {
      ssid: string;
    };
  guestNetworkEnabled: boolean;
  guestNetworkSettings: {
      ssid: string;
    };
  numConnectedDevices: number;
  networkUsageMB: number;
  networkUsageLimitMB: number;
  networkUsageUnlimited: boolean;
};
export type EnableDisableGuestNetworkCommandType = TraitCommandType<'action.devices.commands.EnableDisableGuestNetwork', {
  enable: boolean;
}>;
export type EnableDisableNetworkProfileCommandType = TraitCommandType<'action.devices.commands.EnableDisableNetworkProfile', {
  profile: string;
  enable: boolean;
}>;
export type GetGuestNetworkPasswordCommandType = TraitCommandType<'action.devices.commands.GetGuestNetworkPassword', {
  guestNetworkPassword: string;
}>;
export type TestNetworkSpeedCommandType = TraitCommandType<'action.devices.commands.TestNetworkSpeed', {
  testDownloadSpeed: boolean;
  testUploadSpeed: boolean;
}>;
export type NetworkControlTraitTypeCommands = EnableDisableGuestNetworkCommandType
  | EnableDisableNetworkProfileCommandType
  | GetGuestNetworkPasswordCommandType
  | TestNetworkSpeedCommandType;
export type NetworkControlTraitType = TraitType<
  NetworkControlTraitTypeAttributes,
  NetworkControlTraitTypeStates,
  NetworkControlTraitTypeCommands>;
export type OnOffTraitTypeAttributes = {
  commandOnlyOnOff: boolean | undefined;
  queryOnlyOnOff: boolean | undefined;
};
export type OnOffTraitTypeStates = {
  on: boolean;
};
export type OnOffCommandType = TraitCommandType<'action.devices.commands.OnOff', {
    on: boolean;
  }>;
export type OnOffTraitTypeCommands = OnOffCommandType;
export type OnOffTraitType = TraitType<
  OnOffTraitTypeAttributes,
  OnOffTraitTypeStates,
  OnOffTraitTypeCommands>;
export type OpenCloseTraitTypeAttributes = {
  discreteOnlyOpenClose: boolean | undefined;
  openDirection: {
      UP: string | undefined;
    };
  queryOnlyOpenClose: boolean | undefined;
};
export type OpenCloseTraitTypeStates = {
  openState: {
      openPercent: number;
      openDirection: string;
    };
};
export type OpenCloseCommandType = TraitCommandType<'action.devices.commands.OpenClose', number | undefined>;
export type OpenCloseTraitTypeCommands = OpenCloseCommandType;
export type OpenCloseTraitType = TraitType<
  OpenCloseTraitTypeAttributes,
  OpenCloseTraitTypeStates,
  OpenCloseTraitTypeCommands>;
export type RebootTraitTypeAttributes = {};
export type RebootTraitTypeStates = {};
export type RebootCommandType = TraitCommandType<'action.devices.commands.Reboot', unknown>;
export type RebootTraitTypeCommands = RebootCommandType;
export type RebootTraitType = TraitType<
  RebootTraitTypeAttributes,
  RebootTraitTypeStates,
  RebootTraitTypeCommands>;
export type RotationTraitTypeAttributes = {
  commandOnlyRotation: boolean | undefined;
  supportsContinuousRotation: boolean | undefined;
  supportsDegrees: boolean;
  supportsPercent: boolean;
  rotationDegreesRange: {
      rotationDegreesMin: number;
    };
};
export type RotationTraitTypeStates = {
  rotationPercent: number;
  rotationDegrees: {
      rotationDegreesMin: number;
    };
};
export type RotateAbsoluteCommandType = TraitCommandType<'action.devices.commands.RotateAbsolute', number>;
export type RotationTraitTypeCommands = RotateAbsoluteCommandType;
export type RotationTraitType = TraitType<
  RotationTraitTypeAttributes,
  RotationTraitTypeStates,
  RotationTraitTypeCommands>;
export type RunCycleTraitTypeAttributes = {};
export type RunCycleTraitTypeStates = {
  currentCycle: string;
  nextCycle: string | undefined;
  lang: unknown;
  currentTotalRemainingTime: number;
  currentCycleRemainingTime: number;
};
export type RunCycleTraitTypeCommands = undefined;
export type RunCycleTraitType = TraitType<
  RunCycleTraitTypeAttributes,
  RunCycleTraitTypeStates,
  RunCycleTraitTypeCommands>;
export type SensorStateTraitTypeAttributes = {
  sensorStatesSupported: Array<{
      name: string;
      descriptiveCapabilities: {
          'available_states': Array<string>;
        };
      numericCapabilities: {
          rawValueUnit: string;
        };
    }>;
};
export type SensorStateTraitTypeStates = {
  currentSensorStateData: Array<{
      name: string;
      currentSensorState: string;
      rawValue: number;
    }>;
};
export type SensorStateTraitTypeCommands = undefined;
export type SensorStateTraitType = TraitType<
  SensorStateTraitTypeAttributes,
  SensorStateTraitTypeStates,
  SensorStateTraitTypeCommands>;
export type SceneTraitTypeAttributes = {
  sceneReversible: boolean;
};
export type SceneTraitTypeStates = {};
export type ActivateSceneCommandType = TraitCommandType<'action.devices.commands.ActivateScene', {
    deactivate: boolean;
  }>;
export type SceneTraitTypeCommands = ActivateSceneCommandType;
export type SceneTraitType = TraitType<
  SceneTraitTypeAttributes,
  SceneTraitTypeStates,
  SceneTraitTypeCommands>;
export type SoftwareUpdateTraitTypeAttributes = {};
export type SoftwareUpdateTraitTypeStates = {
  lastSoftwareUpdateUnixTimestampSec: number | undefined;
};
export type SoftwareUpdateCommandType = TraitCommandType<'action.devices.commands.SoftwareUpdate', unknown>;
export type SoftwareUpdateTraitTypeCommands = SoftwareUpdateCommandType;
export type SoftwareUpdateTraitType = TraitType<
  SoftwareUpdateTraitTypeAttributes,
  SoftwareUpdateTraitTypeStates,
  SoftwareUpdateTraitTypeCommands>;
export type StartStopTraitTypeAttributes = {
  pausable: boolean;
  availableZones: Array<string>;
};
export type StartStopTraitTypeStates = {
  isRunning: boolean;
  isPaused: {
      isRunning: boolean;
    };
  activeZones: Array<string> | undefined;
};
export type StartStopCommandType = TraitCommandType<'action.devices.commands.StartStop', boolean | undefined>;
export type PauseUnpauseCommandType = TraitCommandType<'action.devices.commands.PauseUnpause', boolean>;
export type StartStopTraitTypeCommands = StartStopCommandType
  | PauseUnpauseCommandType;
export type StartStopTraitType = TraitType<
  StartStopTraitTypeAttributes,
  StartStopTraitTypeStates,
  StartStopTraitTypeCommands>;
export type StatusReportTraitTypeAttributes = {};
export type StatusReportTraitTypeStates = {
  currentStatusReport: {
      blocking: boolean;
      deviceTarget: string;
      priority: number;
      statusCode: string;
    };
};
export type StatusReportTraitTypeCommands = undefined;
export type StatusReportTraitType = TraitType<
  StatusReportTraitTypeAttributes,
  StatusReportTraitTypeStates,
  StatusReportTraitTypeCommands>;
export type TemperatureControlTraitTypeAttributes = {
  temperatureRange: {
      minThresholdCelsius: number;
      maxThresholdCelsius: number;
    };
  temperatureStepCelsius: number | undefined;
  temperatureUnitForUX: unknown;
  queryOnlyTemperatureControl: {
      temperatureRange: boolean | undefined;
    };
  commandOnlyTemperatureControl: boolean | undefined;
};
export type TemperatureControlTraitTypeStates = {
  temperatureSetpointCelsius: number;
  temperatureAmbientCelsius: number | undefined;
};
export type SetTemperatureCommandType = TraitCommandType<'action.devices.commands.SetTemperature', {
    temperature: number;
  }>;
export type TemperatureControlTraitTypeCommands = SetTemperatureCommandType;
export type TemperatureControlTraitType = TraitType<
  TemperatureControlTraitTypeAttributes,
  TemperatureControlTraitTypeStates,
  TemperatureControlTraitTypeCommands>;
export type TemperatureSettingTraitTypeAttributes = {
  availableThermostatModes: Array<{
      off: unknown;
      heat: unknown;
      cool: unknown;
      on: unknown;
      heatcool: unknown;
      auto: unknown;
      'fan-only': unknown;
      purifier: unknown;
      eco: unknown;
      dry: unknown;
    }>;
  thermostatTemperatureRange: {
      minThresholdCelsius: unknown;
      maxThresholdCelsius: unknown;
    } | undefined;
  thermostatTemperatureUnit: {
      C: unknown;
    };
  bufferRangeCelsius: {
      heatcool: unknown | undefined;
    };
  commandOnlyTemperatureSetting: boolean | undefined;
  queryOnlyTemperatureSetting: boolean | undefined;
};
export type TemperatureSettingTraitTypeStates = {
  activeThermostatMode: {
      availableThermostatModes: string | undefined;
    };
  targetTempReachedEstimateUnixTimestampSec: unknown | undefined;
  thermostatHumidityAmbient: number;
  thermostatMode: unknown;
  thermostatTemperatureAmbient: unknown;
  thermostatTemperatureSetpoint: unknown;
  thermostatTemperatureSetpointHigh: unknown;
  thermostatTemperatureSetpointLow: unknown;
};
export type ThermostatTemperatureSetpointCommandType = TraitCommandType<'action.devices.commands.ThermostatTemperatureSetpoint', {
    thermostatTemperatureSetpoint: number;
  }>;
export type ThermostatTemperatureSetRangeCommandType = TraitCommandType<'action.devices.commands.ThermostatTemperatureSetRange', {
    thermostatTemperatureSetpointHigh: number;
  }>;
export type ThermostatSetModeCommandType = TraitCommandType<'action.devices.commands.ThermostatSetMode', {
    thermostatMode: unknown;
  }>;
export type TemperatureRelativeCommandType = TraitCommandType<'action.devices.commands.TemperatureRelative', {
    thermostatTemperatureRelativeDegree: number;
    thermostatTemperatureRelativeWeight: number;
  }>;
export type TemperatureSettingTraitTypeCommands = ThermostatTemperatureSetpointCommandType
  | ThermostatTemperatureSetRangeCommandType
  | ThermostatSetModeCommandType
  | TemperatureRelativeCommandType;
export type TemperatureSettingTraitType = TraitType<
  TemperatureSettingTraitTypeAttributes,
  TemperatureSettingTraitTypeStates,
  TemperatureSettingTraitTypeCommands>;
export type TimerTraitTypeAttributes = {
  maxTimerLimitSec: number;
  commandOnlyTimer: boolean | undefined;
};
export type TimerTraitTypeStates = {
  timerRemainingSec: {
      maxTimerLimitSec: number;
    };
  timerPaused: boolean | undefined;
};
export type TimerStartCommandType = TraitCommandType<'action.devices.commands.TimerStart', number>;
export type TimerAdjustCommandType = TraitCommandType<'action.devices.commands.TimerAdjust', number>;
export type TimerPauseCommandType = TraitCommandType<'action.devices.commands.TimerPause', {
    timerRemainingSec: unknown;
    noTimerExists: unknown;
  }>;
export type TimerResumeCommandType = TraitCommandType<'action.devices.commands.TimerResume', {
    timerRemainingSec: unknown;
    noTimerExists: unknown;
  }>;
export type TimerCancelCommandType = TraitCommandType<'action.devices.commands.TimerCancel', {
    timerRemainingSec: unknown;
    noTimerExists: unknown;
  }>;
export type TimerTraitTypeCommands = TimerStartCommandType
  | TimerAdjustCommandType
  | TimerPauseCommandType
  | TimerResumeCommandType
  | TimerCancelCommandType;
export type TimerTraitType = TraitType<
  TimerTraitTypeAttributes,
  TimerTraitTypeStates,
  TimerTraitTypeCommands>;
export type TogglesTraitTypeAttributes = {
  availableToggles: {
      name: string;
      'name_values': unknown;
    };
  commandOnlyToggles: boolean | undefined;
};
export type TogglesTraitTypeStates = {
  currentToggleSettings: Array<undefined>;
};
export type SetTogglesCommandType = TraitCommandType<'action.devices.commands.SetToggles', boolean>;
export type TogglesTraitTypeCommands = SetTogglesCommandType;
export type TogglesTraitType = TraitType<
  TogglesTraitTypeAttributes,
  TogglesTraitTypeStates,
  TogglesTraitTypeCommands>;
export type TransportControlTraitTypeAttributes = {
  transportControlSupportedCommands: Array<{
      'CAPTION_CONTROL': unknown;
      NEXT: unknown;
      PAUSE: unknown;
      PREVIOUS: unknown;
      RESUME: unknown;
      'SEEK_RELATIVE': unknown;
      'SEEK_TO_POSITION': unknown;
      'SET_REPEAT': unknown;
      SHUFFLE: unknown;
      STOP: unknown;
    }>;
};
export type TransportControlTraitTypeStates = {};
export type IsOnCommandType = TraitCommandType<'isOn', boolean>;
export type IsSingleCommandType = TraitCommandType<'isSingle', boolean>;
export type TransportControlTraitTypeCommands = IsOnCommandType
  | IsSingleCommandType;
export type TransportControlTraitType = TraitType<
  TransportControlTraitTypeAttributes,
  TransportControlTraitTypeStates,
  TransportControlTraitTypeCommands>;
export type VolumeTraitTypeAttributes = {
  volumeMaxLevel: number;
  volumeCanMuteAndUnmute: boolean;
  volumeDefaultPercentage: number;
  levelStepSize: number;
  commandOnlyVolume: boolean;
};
export type VolumeTraitTypeStates = {
  currentVolume: number;
  isMuted: boolean;
};
export type RelativeStepsCommandType = TraitCommandType<'relativeSteps', number>;
export type VolumeTraitTypeCommands = RelativeStepsCommandType;
export type VolumeTraitType = TraitType<
  VolumeTraitTypeAttributes,
  VolumeTraitTypeStates,
  VolumeTraitTypeCommands>;
